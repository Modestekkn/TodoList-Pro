<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoList Pro</title>
    <link rel="shortcut icon" href="./task-icon.png" type="image/x-icon">
    <!-- Google Fonts - Roboto -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600;700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
        rel="stylesheet">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link rel="stylesheet" href="style.css">
</head>

<body>
    <!-- √âcran de chargement -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-content">
            <div class="loading-logo"><img
                    src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTiViquTVNf5gqaLzyGE_NwLWcfKsUf3I4xIQ&s"
                    alt="Logo de l'app" srcset=""></div>
            <h2 class="loading-title">TodoList Pro</h2>
            <div class="loading-spinner"></div>
            <p class="loading-text">Chargement de votre espace de productivit√©...</p>
        </div>
    </div>

    <!-- Overlay pour fermer la sidebar sur mobile -->
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <div class="app-container" id="app" style="opacity: 0; transition: opacity 0.8s ease-out;">
        <!-- Header -->
        <header class="app-header" role="banner">
            <div class="header-left">
                <button class="btn btn-secondary btn-icon hamburger-btn" id="sidebar-toggle"
                    aria-label="Ouvrir/fermer la barre lat√©rale" aria-expanded="true" aria-controls="sidebar">
                    <i class="fas fa-bars" aria-hidden="true"></i>
                </button>
                <div class="app-logo-container">
                    <div class="app-logo"><i class="fas fa-clipboard-list"></i></div>
                    <h1 class="app-title">TodoList Pro</h1>
                </div>
            </div>

            <div class="header-center">
                <!-- Barre de recherche -->
                <div class="search-container" role="search">
                    <label for="search-input" class="sr-only">Rechercher dans les t√¢ches</label>
                    <input type="text" class="input search-input" id="search-input" placeholder="Rechercher..."
                        aria-label="Rechercher dans les t√¢ches" autocomplete="off">
                    <button class="btn btn-secondary btn-icon" id="clear-search" title="Effacer la recherche"
                        aria-label="Effacer la recherche">
                        <i class="fas fa-times" aria-hidden="true"></i>
                    </button>
                </div>
                <!-- Timer Pomodoro -->
                <div class="pomodoro-timer" id="pomodoro-timer">
                    <span class="timer-display" id="timer-display">25:00</span>
                    <button class="btn btn-secondary btn-icon" id="timer-toggle" title="D√©marrer/Arr√™ter le timer"><i
                            class="fas fa-play"></i></button>
                </div>
                <div class="stats-summary" id="stats-summary">
                    <span class="text-sm text-center">0 t√¢ches</span>
                </div>
            </div>

            <div class="header-right">
                <button class="btn btn-secondary btn-icon" id="focus-mode-toggle" title="Mode Focus"><i
                        class="fas fa-bullseye"></i></button>
                <button class="btn btn-secondary btn-icon" id="theme-toggle">
                    <i class="fas fa-moon"></i>
                </button>
                <button class="btn btn-secondary btn-icon" id="help-btn" title="Aide et documentation"><i
                        class="fas fa-question-circle"></i></button>
                <button class="btn btn-secondary btn-icon" id="settings-btn">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="app-sidebar" id="sidebar">
            <div class="sidebar-content">
                <!-- Bouton de fermeture pour mobile -->
                <div class="sidebar-header mobile-only">
                    <h2 class="sidebar-title">Menu</h2>
                    <button class="mobile-close-btn" id="close-sidebar-btn" aria-label="Fermer le menu">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Navigation principale -->
                <nav class="main-nav">
                    <h3 class="font-medium text-sm text-muted mb-2">VUES</h3>
                    <ul class="nav-list">
                        <li><a href="#" class="nav-item active" data-view="list"><i class="fas fa-list"></i> Liste</a>
                        </li>
                        <li><a href="#" class="nav-item" data-view="kanban"><i class="fas fa-columns"></i> Kanban</a>
                        </li>
                        <li><a href="#" class="nav-item" data-view="calendar"><i class="fas fa-calendar-alt"></i>
                                Calendrier</a></li>
                        <li><a href="#" class="nav-item" data-view="timeline"><i class="fas fa-clock"></i> Timeline</a>
                        </li>
                    </ul>
                </nav>

                <!-- Filtres rapides -->
                <div class="quick-filters">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4">FILTRES</h3>
                    <ul class="filter-list">
                        <li><a href="#" class="filter-item" data-filter="all"><i class="fas fa-tasks"></i> Toutes les
                                t√¢ches</a></li>
                        <li><a href="#" class="filter-item" data-filter="today"><i class="fas fa-calendar-day"></i>
                                Aujourd'hui</a></li>
                        <li><a href="#" class="filter-item" data-filter="upcoming"><i class="fas fa-clock"></i> √Ä
                                venir</a></li>
                        <li><a href="#" class="filter-item" data-filter="overdue"><i
                                    class="fas fa-exclamation-triangle"></i> En retard</a></li>
                        <li><a href="#" class="filter-item" data-filter="completed"><i class="fas fa-check-circle"></i>
                                Termin√©es</a></li>
                        <li><a href="#" class="filter-item" data-filter="favorites"><i class="fas fa-star"></i>
                                Favoris</a></li>
                        <li><a href="#" class="filter-item" data-filter="high-priority"><i class="fas fa-fire"></i>
                                Priorit√© haute</a></li>
                    </ul>
                </div>

                <!-- Statistiques -->
                <div class="stats-widget">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4">STATISTIQUES</h3>
                    <div class="stats-summary-widget" id="stats-widget">
                        <!-- Les statistiques seront g√©n√©r√©es dynamiquement -->
                    </div>
                    <button class="btn btn-secondary text-xs mt-2" id="show-detailed-stats">
                        <i class="fas fa-chart-bar"></i> Voir les d√©tails
                    </button>
                </div>

                <!-- IA et Gamification -->
                <div class="ai-suggestions">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4"><i class="fas fa-robot"></i> SUGGESTIONS IA</h3>
                    <div class="suggestions-container" id="ai-suggestions">
                        <!-- Les suggestions seront g√©n√©r√©es dynamiquement -->
                    </div>
                </div>

                <div class="daily-challenge">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4"><i class="fas fa-bullseye"></i> D√âFI DU JOUR</h3>
                    <div class="challenge-container" id="daily-challenge">
                        <!-- Le d√©fi sera g√©n√©r√© dynamiquement -->
                    </div>
                </div>

                <!-- Mini calendrier -->
                <div class="mini-calendar">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4">CALENDRIER</h3>
                    <div class="calendar-widget" id="mini-calendar">
                        <!-- Le calendrier sera g√©n√©r√© dynamiquement -->
                    </div>
                </div>

                <!-- Cat√©gories -->
                <div class="categories">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4">CAT√âGORIES</h3>
                    <div class="category-list" id="category-list">
                        <!-- Les cat√©gories seront ajout√©es dynamiquement -->
                    </div>
                    <button class="btn btn-secondary text-xs mt-2" id="add-category-btn">
                        + Nouvelle cat√©gorie
                    </button>
                </div>
            </div>
        </aside>

        <!-- Contenu principal -->
        <main class="app-main">
            <div class="main-content" id="main-content">
                <!-- Zone d'ajout de t√¢che -->
                <div class="task-input-section">
                    <div class="task-input-container">
                        <div class="input-with-icon">
                            <i class="fas fa-plus-circle input-icon"></i>
                            <input type="text" class="input" id="task-input" placeholder="Ajouter une nouvelle t√¢che..."
                                autocomplete="off">
                        </div>
                        <div class="task-options">
                            <!-- Ligne 1 : Titre + Priorit√© | Cat√©gorie + Date d'√©ch√©ance -->
                            <div class="form-row main-form">
                                <div class="form-field">
                                    <label for="task-priority" class="form-label">
                                        <i class="fas fa-flag"></i> Priorit√©
                                    </label>
                                    <select class="input" id="task-priority">
                                        <option value="normal">üîµ Normal</option>
                                        <option value="low">üü¢ Basse</option>
                                        <option value="high">üü† Haute</option>
                                        <option value="critical">üî¥ Critique</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <label for="task-category" class="form-label">
                                        <i class="fas fa-folder"></i> Cat√©gorie
                                    </label>
                                    <select class="input" id="task-category">
                                        <option value="">Aucune cat√©gorie</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <label for="task-due-date" class="form-label">
                                        <i class="fas fa-calendar-alt"></i> Date d'√©ch√©ance
                                    </label>
                                    <input type="date" class="input" id="task-due-date">
                                </div>
                            </div>
                            <!-- Ligne 2 : Horaires (prend toute la largeur) -->
                            <div class="form-row time-row">
                                <div class="form-field time-field">
                                    <label class="form-label">
                                        <i class="fas fa-clock"></i> Horaires
                                    </label>
                                    <div class="time-group">
                                        <input type="time" class="input" id="task-start-time" title="Heure de d√©but">
                                        <span class="time-separator">√†</span>
                                        <input type="time" class="input" id="task-end-time" title="Heure de fin">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="buttons-row">
                            <button class="btn btn-primary" id="add-task-btn">
                                <i class="fas fa-plus"></i> Ajouter la t√¢che
                            </button>
                            <button class="btn btn-secondary text-xs toggle-btn" id="toggle-advanced">
                                <i class="fas fa-cog"></i>
                                <span>Options avanc√©es</span>
                                <i class="fas fa-chevron-down toggle-icon"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Options avanc√©es (masqu√©es par d√©faut) -->
                    <div class="advanced-options hidden" id="advanced-options">
                        <h4 class="advanced-options-title">
                            <i class="fas fa-cog"></i> Options avanc√©es
                        </h4>
                        <div class="form-row">
                            <div class="form-field">
                                <label for="task-description" class="form-label">
                                    <i class="fas fa-align-left"></i> Description
                                </label>
                                <input type="text" class="input" id="task-description" placeholder="Description de la t√¢che...">
                            </div>
                            <div class="form-field">
                                <label for="task-tags" class="form-label">
                                    <i class="fas fa-tags"></i> Tags
                                </label>
                                <input type="text" class="input" id="task-tags" placeholder="tag1, tag2, tag3...">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-field">
                                <label for="task-estimated-time" class="form-label">
                                    <i class="fas fa-hourglass-half"></i> Temps estim√© (min)
                                </label>
                                <input type="number" class="input" id="task-estimated-time" placeholder="En minutes" min="1">
                            </div>
                            <div class="form-field">
                                <label for="task-recurring" class="form-label">
                                    <i class="fas fa-redo"></i> R√©currence
                                </label>
                                <select class="input" id="task-recurring">
                                    <option value="">Pas de r√©currence</option>
                                    <option value="daily">Quotidien</option>
                                    <option value="weekly">Hebdomadaire</option>
                                    <option value="monthly">Mensuel</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Zone principale des t√¢ches -->
                <div class="tasks-container" id="tasks-container">
                    <!-- Les t√¢ches seront affich√©es ici -->
                </div>
            </div>
        </main>
    </div>

    <!-- Modal overlay pour les param√®tres et l'aide -->
    <div id="modal-overlay" class="hidden"></div>

    <!-- Modales et overlays -->
    <div class="modal-overlay hidden" id="modal-overlay"></div>

    <script>
        // Architecture modulaire de l'application
        class TodoApp {
            constructor() {
                this.state = {
                    tasks: [],
                    categories: [],
                    currentView: 'list',
                    currentFilter: 'all',
                    theme: 'light',
                    settings: {},
                    calendarDate: new Date() // Initialiser le calendrier sur aujourd'hui
                };

                this.modules = {};
                this.init();
            }

            init() {
                this.loadState();
                this.initDefaultCategories();
                this.initCalendar();
                this.applyTheme();
                this.initAccessibility();
                this.initPerformanceOptimizations();
                this.initModules();
                this.bindEvents();
                this.initMobileLayout();
                this.render();
                this.checkOverdueTasks();

                // Animation d'entr√©e de l'application
                this.animateAppEntrance();

                // V√©rifier les t√¢ches en retard toutes les heures
                setInterval(() => this.checkOverdueTasks(), 3600000);
            }

            animateAppEntrance() {
                // V√©rifier les pr√©f√©rences de mouvement r√©duit
                const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                const delay = prefersReducedMotion ? 200 : 2500;

                // Afficher l'application rapidement
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loading-screen');
                    const app = document.getElementById('app');

                    // Afficher l'application imm√©diatement
                    if (app) {
                        app.style.opacity = '1';
                        app.style.transition = prefersReducedMotion ? 'opacity 0.5s ease-out' : 'opacity 0.8s ease-out';
                    }

                    // Masquer l'√©cran de chargement
                    if (loadingScreen) {
                        loadingScreen.style.opacity = '0';
                        loadingScreen.style.transition = prefersReducedMotion ? 'opacity 0.5s ease-out' : 'opacity 0.8s ease-out';

                        // Supprimer l'√©cran de chargement apr√®s l'animation
                        const removeDelay = prefersReducedMotion ? 200 : 800;
                        setTimeout(() => {
                            loadingScreen.remove();
                        }, removeDelay);
                    }
                }, delay);
            }

            initAccessibility() {
                // D√©tecter les pr√©f√©rences d'accessibilit√©
                if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    document.body.classList.add('reduced-motion');
                }

                if (window.matchMedia('(prefers-contrast: high)').matches) {
                    document.body.classList.add('high-contrast');
                }

                // G√©rer les annonces pour les lecteurs d'√©cran
                this.createAriaLiveRegion();

                // Am√©liorer la navigation au clavier
                this.setupKeyboardNavigation();
            }

            createAriaLiveRegion() {
                const liveRegion = document.createElement('div');
                liveRegion.id = 'aria-live-region';
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.className = 'sr-only';
                document.body.appendChild(liveRegion);
            }

            announceToScreenReader(message) {
                const liveRegion = document.getElementById('aria-live-region');
                if (liveRegion) {
                    liveRegion.textContent = message;
                    setTimeout(() => {
                        liveRegion.textContent = '';
                    }, 1000);
                }
            }

            setupKeyboardNavigation() {
                // Am√©liorer la navigation dans les listes
                document.addEventListener('keydown', (e) => {
                    if (e.target.classList.contains('nav-item') || e.target.classList.contains('filter-item')) {
                        this.handleListNavigation(e);
                    }
                });
            }

            handleListNavigation(e) {
                const items = Array.from(e.target.parentElement.children);
                const currentIndex = items.indexOf(e.target);
                let nextIndex;

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        nextIndex = (currentIndex + 1) % items.length;
                        items[nextIndex].focus();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        nextIndex = currentIndex === 0 ? items.length - 1 : currentIndex - 1;
                        items[nextIndex].focus();
                        break;
                    case 'Home':
                        e.preventDefault();
                        items[0].focus();
                        break;
                    case 'End':
                        e.preventDefault();
                        items[items.length - 1].focus();
                        break;
                }
            }

            initPerformanceOptimizations() {
                // Debounce pour la recherche
                this.searchDebounce = this.debounce((query) => {
                    this.performSearch(query);
                }, 300);

                // Throttle pour le scroll
                this.scrollThrottle = this.throttle(() => {
                    this.handleScroll();
                }, 100);

                // Observer pour le lazy loading
                this.setupIntersectionObserver();
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            throttle(func, limit) {
                let inThrottle;
                return function () {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            }

            setupIntersectionObserver() {
                if ('IntersectionObserver' in window) {
                    this.intersectionObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                this.loadLazyContent(entry.target);
                            }
                        });
                    }, {
                        rootMargin: '50px'
                    });
                }
            }

            loadLazyContent(element) {
                // Charger le contenu lazy
                if (element.dataset.lazy === 'true') {
                    element.dataset.lazy = 'false';
                    // Logique de chargement du contenu
                    this.intersectionObserver.unobserve(element);
                }
            }

            applyTheme() {
                if (this.state.theme && this.state.theme !== 'light') {
                    this.setTheme(this.state.theme);
                }
            }

            checkOverdueTasks() {
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

                const overdueTasks = this.state.tasks.filter(task => {
                    if (!task.dueDate || task.completed) return false;
                    return new Date(task.dueDate) < today;
                });

                if (overdueTasks.length > 0) {
                    const message = overdueTasks.length === 1 ?
                        '1 t√¢che en retard !' :
                        `${overdueTasks.length} t√¢ches en retard !`;

                    // Afficher une notification discr√®te
                    setTimeout(() => {
                        this.showNotification(message, 'warning');
                    }, 2000);
                }
            }

            loadState() {
                // Chargement de l'√©tat depuis localStorage
                const savedState = localStorage.getItem('todoapp-state');
                if (savedState) {
                    this.state = { ...this.state, ...JSON.parse(savedState) };
                }

                // Restaurer l'√©tat du sidebar
                const sidebarCollapsed = localStorage.getItem('sidebar-collapsed') === 'true';
                if (sidebarCollapsed && window.innerWidth > 768) {
                    const sidebar = document.getElementById('sidebar');
                    const container = document.getElementById('app');
                    sidebar.classList.add('hidden');
                    container.classList.add('sidebar-collapsed');
                }
            }

            saveState() {
                // Sauvegarde de l'√©tat dans localStorage
                localStorage.setItem('todoapp-state', JSON.stringify(this.state));
            }

            initModules() {
                // Initialisation des modules (sera √©tendu)
                console.log('Initialisation des modules...');
            }

            bindEvents() {
                // Liaison des √©v√©nements de base
                document.getElementById('sidebar-toggle').addEventListener('click', this.toggleSidebar.bind(this));
                document.getElementById('theme-toggle').addEventListener('click', this.toggleTheme.bind(this));
                document.getElementById('add-task-btn').addEventListener('click', this.addTask.bind(this));
                document.getElementById('task-input').addEventListener('keypress', this.handleTaskInputKeypress.bind(this));
                document.getElementById('toggle-advanced').addEventListener('click', this.toggleAdvancedOptions.bind(this));
                document.getElementById('add-category-btn').addEventListener('click', this.addCategory.bind(this));
                document.getElementById('search-input').addEventListener('input', this.handleSearch.bind(this));
                document.getElementById('clear-search').addEventListener('click', this.clearSearch.bind(this));
                document.getElementById('timer-toggle').addEventListener('click', this.togglePomodoroTimer.bind(this));
                document.getElementById('focus-mode-toggle').addEventListener('click', this.toggleFocusMode.bind(this));
                document.getElementById('settings-btn').addEventListener('click', this.showSettings.bind(this));
                document.getElementById('show-detailed-stats').addEventListener('click', this.showDetailedStats.bind(this));
                document.getElementById('help-btn').addEventListener('click', this.showHelp.bind(this));

                // √âv√©nements pour les filtres et vues
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.changeView(item.dataset.view);
                    });
                });

                document.querySelectorAll('.filter-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.changeFilter(item.dataset.filter);
                    });
                });

                // Raccourcis clavier
                document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));

                // Gestion mobile de la sidebar
                document.getElementById('sidebar-overlay').addEventListener('click', this.closeSidebar.bind(this));
                document.getElementById('close-sidebar-btn').addEventListener('click', this.closeSidebar.bind(this));

                // Gestion du redimensionnement pour le responsive
                window.addEventListener('resize', this.handleResize.bind(this));
            }

            // Gestion mobile de la sidebar
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const container = document.getElementById('app');
                const isMobile = window.innerWidth <= 768;

                if (isMobile) {
                    sidebar.classList.toggle('open');
                    overlay.classList.toggle('active');
                } else {
                    sidebar.classList.toggle('hidden');
                    // Ajouter classe au container pour faciliter le CSS
                    container.classList.toggle('sidebar-collapsed');
                    
                    // Sauvegarder l'√©tat du sidebar
                    const isCollapsed = sidebar.classList.contains('hidden');
                    localStorage.setItem('sidebar-collapsed', isCollapsed.toString());
                }
            }

            closeSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');

                sidebar.classList.remove('open');
                overlay.classList.remove('active');
            }

            handleResize() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const isMobile = window.innerWidth <= 768;

                if (!isMobile) {
                    sidebar.classList.remove('open');
                    overlay.classList.remove('active');
                }
            }

            initMobileLayout() {
                // S'assurer que la sidebar soit ferm√©e par d√©faut sur mobile
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    this.closeSidebar();
                }
            }

            handleKeyboardShortcuts(e) {
                // Ignorer si on est dans un champ de saisie
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    // Permettre Escape pour sortir des champs
                    if (e.key === 'Escape') {
                        e.target.blur();
                    }
                    return;
                }

                // Raccourcis globaux
                switch (e.key) {
                    case 'n':
                    case 'N':
                        // Nouvelle t√¢che
                        e.preventDefault();
                        document.getElementById('task-input').focus();
                        break;
                    case 'f':
                    case 'F':
                        // Focus sur la recherche
                        e.preventDefault();
                        document.getElementById('search-input').focus();
                        break;
                    case 's':
                    case 'S':
                        // Sauvegarder (d√©j√† automatique, mais feedback)
                        e.preventDefault();
                        this.showNotification('Sauvegarde automatique active', 'info');
                        break;
                    case 't':
                    case 'T':
                        // Toggle timer Pomodoro
                        e.preventDefault();
                        this.togglePomodoroTimer();
                        break;
                    case 'z':
                    case 'Z':
                        // Mode Focus
                        e.preventDefault();
                        this.toggleFocusMode();
                        break;
                    case 'd':
                    case 'D':
                        // Th√®me sombre
                        e.preventDefault();
                        this.toggleTheme();
                        break;
                    case '1':
                        e.preventDefault();
                        this.changeFilter('all');
                        break;
                    case '2':
                        e.preventDefault();
                        this.changeFilter('today');
                        break;
                    case '3':
                        e.preventDefault();
                        this.changeFilter('upcoming');
                        break;
                    case '4':
                        e.preventDefault();
                        this.changeFilter('overdue');
                        break;
                    case '5':
                        e.preventDefault();
                        this.changeFilter('completed');
                        break;
                    case 'Escape':
                        // Effacer la recherche ou sortir du mode focus
                        if (this.state.searchQuery) {
                            this.clearSearch();
                        } else if (document.body.classList.contains('focus-mode')) {
                            this.toggleFocusMode();
                        }
                        break;
                    case '?':
                        // Afficher l'aide des raccourcis
                        e.preventDefault();
                        this.showKeyboardHelp();
                        break;
                }
            }

            showKeyboardHelp() {
                const helpText = `
Raccourcis clavier disponibles:

N - Nouvelle t√¢che
F - Rechercher
T - Timer Pomodoro
Z - Mode Focus
D - Th√®me sombre
S - Sauvegarder

1 - Toutes les t√¢ches
2 - Aujourd'hui
3 - √Ä venir
4 - En retard
5 - Termin√©es

Escape - Effacer recherche/Sortir du mode focus
? - Afficher cette aide
                `;

                this.alert(helpText, 'Aide - Raccourcis clavier');
            }

            // M√©thodes pour les popups personnalis√©es
            async prompt(message, defaultValue = '', title = 'Saisie') {
                return new Promise((resolve) => {
                    const overlay = document.getElementById('modal-overlay');
                    const promptHTML = `
                        <div class="popup-content" style="max-width: 400px;">
                            <div class="popup-header">
                                <h3>${title}</h3>
                                <button class="btn-close" onclick="this.closest('.popup-content').parentElement.classList.add('hidden'); document.querySelector('.popup-input').resolve(null);">√ó</button>
                            </div>
                            <div class="popup-body">
                                <p>${message}</p>
                                <input type="text" class="input popup-input" value="${defaultValue}" placeholder="Entrez votre r√©ponse..." style="width: 100%; margin-top: 10px;">
                            </div>
                            <div class="popup-footer">
                                <button class="btn btn-secondary popup-cancel">Annuler</button>
                                <button class="btn btn-primary popup-confirm">Confirmer</button>
                            </div>
                        </div>
                    `;

                    overlay.innerHTML = promptHTML;
                    overlay.classList.remove('hidden');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;

                    const input = overlay.querySelector('.popup-input');
                    const confirmBtn = overlay.querySelector('.popup-confirm');
                    const cancelBtn = overlay.querySelector('.popup-cancel');
                    const closeBtn = overlay.querySelector('.btn-close');

                    input.focus();
                    input.select();

                    const closeModal = (result) => {
                        overlay.classList.add('hidden');
                        resolve(result);
                    };

                    confirmBtn.addEventListener('click', () => {
                        closeModal(input.value.trim() || null);
                    });

                    cancelBtn.addEventListener('click', () => {
                        closeModal(null);
                    });

                    closeBtn.addEventListener('click', () => {
                        closeModal(null);
                    });

                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            closeModal(input.value.trim() || null);
                        } else if (e.key === 'Escape') {
                            closeModal(null);
                        }
                    });

                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            closeModal(null);
                        }
                    });
                });
            }

            async alert(message, title = 'Information') {
                return new Promise((resolve) => {
                    const overlay = document.getElementById('modal-overlay');
                    const alertHTML = `
                        <div class="popup-content" style="max-width: 400px;">
                            <div class="popup-header">
                                <h3>${title}</h3>
                                <button class="btn-close" onclick="this.closest('.popup-content').parentElement.classList.add('hidden');">√ó</button>
                            </div>
                            <div class="popup-body">
                                <p style="white-space: pre-line;">${message}</p>
                            </div>
                            <div class="popup-footer">
                                <button class="btn btn-primary popup-ok">OK</button>
                            </div>
                        </div>
                    `;

                    overlay.innerHTML = alertHTML;
                    overlay.classList.remove('hidden');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;

                    const okBtn = overlay.querySelector('.popup-ok');
                    const closeBtn = overlay.querySelector('.btn-close');

                    const closeModal = () => {
                        overlay.classList.add('hidden');
                        resolve();
                    };

                    okBtn.addEventListener('click', closeModal);
                    closeBtn.addEventListener('click', closeModal);

                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            closeModal();
                        }
                    });

                    document.addEventListener('keydown', function escapeHandler(e) {
                        if (e.key === 'Escape') {
                            document.removeEventListener('keydown', escapeHandler);
                            closeModal();
                        }
                    });
                });
            }

            async confirm(message, title = 'Confirmation') {
                return new Promise((resolve) => {
                    const overlay = document.getElementById('modal-overlay');
                    const confirmHTML = `
                        <div class="popup-content" style="max-width: 400px;">
                            <div class="popup-header">
                                <h3>${title}</h3>
                                <button class="btn-close" onclick="this.closest('.popup-content').parentElement.classList.add('hidden');">√ó</button>
                            </div>
                            <div class="popup-body">
                                <p style="white-space: pre-line;">${message}</p>
                            </div>
                            <div class="popup-footer">
                                <button class="btn btn-secondary popup-cancel">Annuler</button>
                                <button class="btn btn-danger popup-confirm">Confirmer</button>
                            </div>
                        </div>
                    `;

                    overlay.innerHTML = confirmHTML;
                    overlay.classList.remove('hidden');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;

                    const confirmBtn = overlay.querySelector('.popup-confirm');
                    const cancelBtn = overlay.querySelector('.popup-cancel');
                    const closeBtn = overlay.querySelector('.btn-close');

                    const closeModal = (result) => {
                        overlay.classList.add('hidden');
                        resolve(result);
                    };

                    confirmBtn.addEventListener('click', () => {
                        closeModal(true);
                    });

                    cancelBtn.addEventListener('click', () => {
                        closeModal(false);
                    });

                    closeBtn.addEventListener('click', () => {
                        closeModal(false);
                    });

                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            closeModal(false);
                        }
                    });

                    document.addEventListener('keydown', function escapeHandler(e) {
                        if (e.key === 'Escape') {
                            document.removeEventListener('keydown', escapeHandler);
                            closeModal(false);
                        }
                    });
                });
            }

            // Vues avanc√©es

            // Vue Kanban
            renderKanbanView() {
                const container = document.getElementById('tasks-container');

                const columns = [
                    { id: 'todo', title: '<i class="fas fa-tasks"></i> √Ä faire', filter: (task) => !task.completed && !task.dependencies?.some(depId => !this.state.tasks.find(t => t.id === depId)?.completed) },
                    { id: 'in-progress', title: '<i class="fas fa-spinner"></i> En cours', filter: (task) => !task.completed && task.actualTime > 0 },
                    { id: 'blocked', title: '<i class="fas fa-ban"></i> Bloqu√©es', filter: (task) => !task.completed && !this.canCompleteTask(task) },
                    { id: 'done', title: '<i class="fas fa-check-circle"></i> Termin√©es', filter: (task) => task.completed }
                ];

                let kanbanHTML = '<div class="kanban-board">';

                columns.forEach(column => {
                    const tasks = this.state.tasks.filter(column.filter);

                    kanbanHTML += `
                        <div class="kanban-column" data-column="${column.id}">
                            <div class="kanban-header">
                                <div class="kanban-title">
                                    ${column.title}
                                    <span class="kanban-count">${tasks.length}</span>
                                </div>
                            </div>
                            <div class="kanban-tasks" ondrop="app.handleKanbanDrop(event, '${column.id}')" ondragover="app.handleKanbanDragOver(event)">
                    `;

                    tasks.forEach(task => {
                        kanbanHTML += this.createKanbanTaskElement(task);
                    });

                    kanbanHTML += '</div></div>';
                });

                kanbanHTML += '</div>';
                container.innerHTML = kanbanHTML;
            }

            createKanbanTaskElement(task) {
                const categoryInfo = this.getCategoryInfo(task.category);
                const dueDateInfo = this.getDueDateInfo(task.dueDate);

                return `
                    <div class="kanban-task priority-${task.priority}" draggable="true"
                         ondragstart="app.handleKanbanDragStart(event, '${task.id}')"
                         data-task-id="${task.id}">
                        <div class="task-header">
                            <span class="task-title">${task.title}</span>
                            ${categoryInfo}
                        </div>
                        ${task.description ? `<div class="task-description">${task.description}</div>` : ''}
                        ${dueDateInfo}
                        ${task.timeRange ? `<div class="task-time-range"><i class="fas fa-clock"></i> ${task.timeRange}</div>` : ''}
                        ${task.subtasks.length > 0 ? `<div class="task-subtasks-count">${task.subtasks.filter(st => st.completed).length}/${task.subtasks.length} sous-t√¢ches</div>` : ''}
                        <div class="task-actions" style="opacity: 1; margin-top: 8px;">
                            <button class="btn-icon" onclick="app.editTask('${task.id}')" title="Modifier"><i class="fas fa-edit"></i></button>
                            <button class="btn-icon" onclick="app.toggleTask('${task.id}')" title="${task.completed ? 'Marquer comme non termin√©e' : 'Marquer comme termin√©e'}">
                                <i class="fas ${task.completed ? 'fa-undo' : 'fa-check'}"></i>
                            </button>
                        </div>
                    </div>
                `;
            }

            handleKanbanDragStart(e, taskId) {
                e.dataTransfer.setData('text/plain', taskId);
                e.target.classList.add('dragging');
            }

            handleKanbanDragOver(e) {
                e.preventDefault();
                e.currentTarget.closest('.kanban-column').classList.add('drag-over');
            }

            handleKanbanDrop(e, columnId) {
                e.preventDefault();
                const taskId = e.dataTransfer.getData('text/plain');
                const task = this.state.tasks.find(t => t.id === taskId);

                if (task) {
                    // Logique de changement d'√©tat selon la colonne
                    switch (columnId) {
                        case 'todo':
                            task.completed = false;
                            task.actualTime = 0;
                            break;
                        case 'in-progress':
                            task.completed = false;
                            if (task.actualTime === 0) {
                                task.actualTime = 1; // Marquer comme commenc√©e
                            }
                            break;
                        case 'done':
                            if (this.canCompleteTask(task)) {
                                task.completed = true;
                                task.completedAt = new Date().toISOString();
                            } else {
                                this.showNotification('Impossible de terminer: d√©pendances non satisfaites', 'warning');
                                return;
                            }
                            break;
                    }

                    task.updatedAt = new Date().toISOString();
                    this.saveState();
                    this.render();
                    this.showNotification('T√¢che d√©plac√©e !', 'success');
                }

                // Nettoyer les classes
                document.querySelectorAll('.kanban-column').forEach(col => {
                    col.classList.remove('drag-over');
                });
                document.querySelectorAll('.kanban-task').forEach(task => {
                    task.classList.remove('dragging');
                });
            }

            // Vue Timeline
            renderTimelineView() {
                const container = document.getElementById('tasks-container');

                // Filtrer et trier les t√¢ches avec dates d'√©ch√©ance
                const tasksWithDates = this.state.tasks
                    .filter(task => task.dueDate)
                    .sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));

                if (tasksWithDates.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <p class="text-muted">Aucune t√¢che avec date d'√©ch√©ance</p>
                            <p class="text-xs text-muted">Ajoutez des dates d'√©ch√©ance √† vos t√¢ches pour les voir dans la timeline</p>
                        </div>
                    `;
                    return;
                }

                let timelineHTML = `
                    <div class="timeline-view">
                        <div class="timeline-container">
                            <div class="timeline-line"></div>
                `;

                tasksWithDates.forEach((task, index) => {
                    const isLeft = index % 2 === 0;
                    const dueDate = new Date(task.dueDate);
                    const isOverdue = dueDate < new Date() && !task.completed;
                    const categoryInfo = this.getCategoryInfo(task.category);

                    timelineHTML += `
                        <div class="timeline-item ${isLeft ? 'left' : 'right'}">
                            <div class="timeline-content ${isOverdue ? 'overdue' : ''} ${task.completed ? 'completed' : ''}">
                                <div class="task-header">
                                    <span class="task-priority priority-${task.priority}">${this.getPriorityIcon(task.priority)}</span>
                                    <span class="task-title ${task.completed ? 'completed' : ''}">${task.title}</span>
                                    ${categoryInfo}
                                </div>
                                ${task.description ? `<div class="task-description">${task.description}</div>` : ''}
                                ${task.subtasks.length > 0 ? `<div class="task-subtasks-count">${task.subtasks.filter(st => st.completed).length}/${task.subtasks.length} sous-t√¢ches</div>` : ''}
                                <div class="task-actions" style="margin-top: 8px;">
                                    <button class="btn-icon" onclick="app.editTask('${task.id}')" title="Modifier"><i class="fas fa-edit"></i></button>
                                    <button class="btn-icon" onclick="app.toggleTask('${task.id}')" title="${task.completed ? 'Marquer comme non termin√©e' : 'Marquer comme termin√©e'}">
                                        <i class="fas ${task.completed ? 'fa-undo' : 'fa-check'}"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="timeline-date">
                                ${dueDate.toLocaleDateString('fr-FR')}
                            </div>
                            <div class="timeline-dot ${task.completed ? 'completed' : ''} ${isOverdue ? 'overdue' : ''}"></div>
                        </div>
                    `;
                });

                timelineHTML += '</div></div>';
                container.innerHTML = timelineHTML;
            }

            // Vue Calendrier compl√®te
            renderCalendarView() {
                const container = document.getElementById('tasks-container');
                const currentDate = this.state.calendarDate ? new Date(this.state.calendarDate) : new Date();

                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const startDate = new Date(firstDay);
                startDate.setDate(startDate.getDate() - firstDay.getDay());

                const monthNames = [
                    'Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
                    'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'
                ];

                const dayNames = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];

                let calendarHTML = `
                    <div class="calendar-view">
                        <div class="calendar-full">
                            <div class="calendar-full-header">
                                <button class="btn btn-secondary" onclick="app.changeCalendarMonth(-1)">‚Äπ Pr√©c√©dent</button>
                                <h2>${monthNames[month]} ${year}</h2>
                                <button class="btn btn-secondary" onclick="app.changeCalendarMonth(1)">Suivant ‚Ä∫</button>
                            </div>
                            <div class="calendar-full-grid">
                `;

                // En-t√™tes des jours
                dayNames.forEach(day => {
                    calendarHTML += `<div class="calendar-day-header" style="padding: 12px; font-weight: 600; background: var(--bg-tertiary);">${day}</div>`;
                });

                // Jours du calendrier
                const today = new Date();
                for (let i = 0; i < 42; i++) {
                    const date = new Date(startDate);
                    date.setDate(startDate.getDate() + i);

                    const isToday = date.toDateString() === today.toDateString();
                    const isCurrentMonth = date.getMonth() === month;
                    const tasksForDay = this.getTasksForDate(date);

                    let dayClass = 'calendar-full-day';
                    if (isToday) dayClass += ' today';
                    if (!isCurrentMonth) dayClass += ' other-month';

                    calendarHTML += `
                        <div class="${dayClass}">
                            <div class="calendar-day-number">${date.getDate()}</div>
                    `;

                    // Afficher les t√¢ches du jour
                    tasksForDay.slice(0, 3).forEach(task => {
                        const isOverdue = new Date(task.dueDate) < today && !task.completed;
                        calendarHTML += `
                            <div class="calendar-task-item ${task.completed ? 'completed' : ''} ${isOverdue ? 'overdue' : ''}"
                                 onclick="app.editTask('${task.id}')"
                                 title="${task.title}${task.description ? ' - ' + task.description : ''}"
                                 style="background-color: ${task.completed ? 'var(--secondary-color)' : (isOverdue ? 'var(--danger-color)' : 'var(--primary-color)')}">
                                ${task.title}
                            </div>
                        `;
                    });

                    if (tasksForDay.length > 3) {
                        calendarHTML += `<div class="calendar-task-item" style="background: var(--text-muted);">+${tasksForDay.length - 3} autres</div>`;
                    }

                    calendarHTML += '</div>';
                }

                calendarHTML += '</div></div></div>';
                container.innerHTML = calendarHTML;
            }

            toggleAdvancedOptions() {
                const advancedOptions = document.getElementById('advanced-options');
                const toggleBtn = document.getElementById('toggle-advanced');

                if (advancedOptions.classList.contains('hidden')) {
                    advancedOptions.classList.remove('hidden');
                    toggleBtn.innerHTML = `
                        <i class="fas fa-cog"></i>
                        <span>Masquer les options</span>
                        <i class="fas fa-chevron-up toggle-icon"></i>
                    `;
                    toggleBtn.classList.add('expanded');
                } else {
                    advancedOptions.classList.add('hidden');
                    toggleBtn.innerHTML = `
                        <i class="fas fa-cog"></i>
                        <span>Options avanc√©es</span>
                        <i class="fas fa-chevron-down toggle-icon"></i>
                    `;
                    toggleBtn.classList.remove('expanded');
                }
            }

            async addCategory() {
                const name = await this.prompt('Nom de la nouvelle cat√©gorie:', '', 'Nouvelle cat√©gorie');
                if (name && name.trim()) {
                    const colors = ['#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'];
                    const color = colors[Math.floor(Math.random() * colors.length)];

                    const category = {
                        id: Date.now().toString(),
                        name: name.trim(),
                        color,
                        createdAt: new Date().toISOString()
                    };

                    this.state.categories.push(category);
                    this.saveState();
                    this.renderCategories();
                    this.showNotification('Cat√©gorie ajout√©e !', 'success');
                }
            }

            changeView(view) {
                this.state.currentView = view;

                // Mettre √† jour l'interface
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`[data-view="${view}"]`).classList.add('active');

                this.render();
                this.showNotification(`Vue chang√©e: ${view}`, 'info');
            }

            changeFilter(filter) {
                this.state.currentFilter = filter;
                this.render();
                this.showNotification(`Filtre appliqu√©: ${filter}`, 'info');
            }

            toggleTheme() {
                // Syst√®me de th√®mes simplifi√© - seulement 3 th√®mes
                const themes = ['light', 'dark', 'minimal'];
                const currentIndex = themes.indexOf(this.state.theme || 'light');
                const nextIndex = (currentIndex + 1) % themes.length;

                this.setTheme(themes[nextIndex]);
            }

            setTheme(theme) {
                // Retirer tous les th√®mes existants
                document.body.classList.remove('dark-theme', 'minimal-theme');

                // Appliquer le nouveau th√®me
                this.state.theme = theme;
                if (theme !== 'light') {
                    document.body.classList.add(`${theme}-theme`);
                }

                // Mettre √† jour l'ic√¥ne du bouton
                const themeIcons = {
                    light: 'fa-sun',
                    dark: 'fa-moon',
                    minimal: 'fa-circle'
                };

                const themeNames = {
                    light: 'Clair',
                    dark: 'Sombre',
                    minimal: 'Minimal'
                };

                const themeIcon = document.querySelector('#theme-toggle i');
                if (themeIcon) {
                    themeIcon.className = `fas ${themeIcons[theme]}`;
                }
                this.saveState();
                this.showNotification(`Th√®me ${themeNames[theme]} activ√©`, 'success');
            }

            addTask() {
                const input = document.getElementById('task-input');
                const title = input.value.trim();

                if (title) {
        // R√©cup√©rer toutes les valeurs du formulaire
        const priority = document.getElementById('task-priority').value;
        const categoryId = document.getElementById('task-category').value || null;
        const dueDate = document.getElementById('task-due-date').value || null;
        const startTime = document.getElementById('task-start-time').value || null;
        const endTime = document.getElementById('task-end-time').value || null;
        const description = document.getElementById('task-description').value.trim();
        const tagsInput = document.getElementById('task-tags').value.trim();
        const estimatedTime = document.getElementById('task-estimated-time').value || null;
        const recurring = document.getElementById('task-recurring').value || null;                    const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag) : [];

        // Valider les horaires si fournis
        let timeRange = null;
        if (startTime && endTime) {
            const startMinutes = this.timeToMinutes(startTime);
            const endMinutes = this.timeToMinutes(endTime);
            if (endMinutes <= startMinutes) {
                this.showNotification('L\'heure de fin doit √™tre apr√®s l\'heure de d√©but', 'error');
                return;
            }
            timeRange = `${startTime} - ${endTime}`;
        } else if (startTime || endTime) {
            timeRange = startTime ? `${startTime} - ?` : `? - ${endTime}`;
        }

        const task = {
            id: Date.now().toString(),
            title,
            completed: false,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            priority,
            category: categoryId,
            dueDate,
            startTime,
            endTime,
            timeRange,
            description,
            tags,
            estimatedTime: estimatedTime ? parseInt(estimatedTime) : null,
            actualTime: 0,
            subtasks: [],
            dependencies: [],
            recurring,
            favorite: false
        };                    this.state.tasks.unshift(task);

                    // R√©initialiser le formulaire
                    this.resetTaskForm();

                    // Animation d'ajout
                    this.animateTaskAdd();

                    this.saveState();
                    this.render();

                    // Notification de succ√®s
                    this.showNotification('T√¢che ajout√©e avec succ√®s !', 'success');
                }
            }

            timeToMinutes(timeString) {
                const [hours, minutes] = timeString.split(':').map(Number);
                return hours * 60 + minutes;
            }

            resetTaskForm() {
                document.getElementById('task-input').value = '';
                document.getElementById('task-priority').value = 'normal';
                document.getElementById('task-category').value = '';
                document.getElementById('task-due-date').value = '';
                document.getElementById('task-start-time').value = '';
                document.getElementById('task-end-time').value = '';
                document.getElementById('task-description').value = '';
                document.getElementById('task-tags').value = '';
                document.getElementById('task-estimated-time').value = '';
                document.getElementById('task-recurring').value = '';

                // Masquer les options avanc√©es
                document.getElementById('advanced-options').classList.add('hidden');
                const toggleBtn = document.getElementById('toggle-advanced');
                toggleBtn.innerHTML = `
                    <i class="fas fa-cog"></i>
                    <span>Options avanc√©es</span>
                    <i class="fas fa-chevron-down toggle-icon"></i>
                `;
                toggleBtn.classList.remove('expanded');
            }

            animateTaskAdd() {
                const input = document.getElementById('task-input');
                input.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    input.style.transform = 'scale(1)';
                }, 150);
            }

            showNotification(message, type = 'info') {
                // Syst√®me de notification plus discret avec toast
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.innerHTML = `
                    <span class="toast-icon">
                        ${type === 'success' ? '‚úì' : type === 'error' ? '‚úó' : type === 'warning' ? '‚ö†' : '‚Ñπ'}
                    </span>
                    <span class="toast-message">${message}</span>
                `;

                // Styles inline pour √©viter la d√©pendance CSS
                toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: var(--bg-primary);
                    color: var(--text-primary);
                    padding: 10px 16px;
                    border-radius: 6px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 1000;
                    font-size: 14px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    border-left: 3px solid ${type === 'success' ? 'var(--priority-low)' : 
                                           type === 'error' ? 'var(--priority-critical)' : 
                                           type === 'warning' ? 'var(--priority-high)' : 'var(--primary-color)'};
                    transform: translateX(100%);
                    transition: transform 0.3s ease-out;
                    max-width: 320px;
                `;

                document.body.appendChild(toast);

                // Animation d'entr√©e
                requestAnimationFrame(() => {
                    toast.style.transform = 'translateX(0)';
                });

                // Annoncer aux lecteurs d'√©cran
                this.announceToScreenReader(message);

                // Supprimer apr√®s 2.5 secondes (r√©duit de 3s)
                setTimeout(() => {
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }, 2500);
            }

            handleTaskInputKeypress(e) {
                if (e.key === 'Enter') {
                    this.addTask();
                }
            }

            render() {
                switch (this.state.currentView) {
                    case 'kanban':
                        this.renderKanbanView();
                        break;
                    case 'calendar':
                        this.renderCalendarView();
                        break;
                    case 'timeline':
                        this.renderTimelineView();
                        break;
                    default:
                        this.renderTasks();
                        break;
                }
                this.renderStats();
                this.renderCategories();
                this.renderMiniCalendar();
                this.renderStatsWidget();
                this.renderAISuggestions();
                this.renderDailyChallenge();
            }

            renderCategories() {
                const categorySelect = document.getElementById('task-category');
                const categoryList = document.getElementById('category-list');

                // Mettre √† jour le select des cat√©gories
                categorySelect.innerHTML = '<option value="">Aucune cat√©gorie</option>';
                this.state.categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category.id;
                    option.textContent = category.name;
                    categorySelect.appendChild(option);
                });

                // Mettre √† jour la liste des cat√©gories dans la sidebar
                categoryList.innerHTML = '';
                this.state.categories.forEach(category => {
                    const categoryItem = document.createElement('div');
                    categoryItem.className = 'category-item';
                    categoryItem.innerHTML = `
                        <div class="category-info" onclick="app.filterByCategory('${category.id}')">
                            <span class="category-color" style="background-color: ${category.color}"></span>
                            <span class="category-name">${category.name}</span>
                            <span class="category-count">${this.getTaskCountByCategory(category.id)}</span>
                        </div>
                        <button class="btn-icon" onclick="app.deleteCategory('${category.id}')" title="Supprimer"><i class="fas fa-trash"></i></button>
                    `;
                    categoryList.appendChild(categoryItem);
                });
            }

            getTaskCountByCategory(categoryId) {
                return this.state.tasks.filter(task => task.category === categoryId && !task.completed).length;
            }

            filterByCategory(categoryId) {
                this.state.currentFilter = 'category';
                this.state.selectedCategory = categoryId;
                this.render();
            }

            async deleteCategory(categoryId) {
                const confirmed = await this.confirm('Supprimer cette cat√©gorie ? Les t√¢ches associ√©es ne seront pas supprim√©es.', 'Supprimer la cat√©gorie');
                if (confirmed) {
                    this.state.categories = this.state.categories.filter(c => c.id !== categoryId);
                    // Retirer la cat√©gorie des t√¢ches
                    this.state.tasks.forEach(task => {
                        if (task.category === categoryId) {
                            task.category = null;
                        }
                    });
                    this.saveState();
                    this.render();
                    this.showNotification('Cat√©gorie supprim√©e', 'info');
                }
            }

            renderTasks() {
                const container = document.getElementById('tasks-container');
                container.innerHTML = '';

                // Appliquer les filtres
                let filteredTasks = this.filterTasks(this.state.currentFilter);

                // Filtrage par cat√©gorie si s√©lectionn√©e
                if (this.state.currentFilter === 'category' && this.state.selectedCategory) {
                    filteredTasks = filteredTasks.filter(task => task.category === this.state.selectedCategory);
                }

                // Tri des t√¢ches
                filteredTasks = this.sortTasks(filteredTasks);

                if (filteredTasks.length === 0) {
                    const emptyMessage = this.state.currentFilter === 'all' ?
                        'Aucune t√¢che pour le moment' :
                        `Aucune t√¢che pour le filtre "${this.state.currentFilter}"`;

                    container.innerHTML = `
                        <div class="empty-state" role="status" aria-live="polite">
                            <p class="text-muted">${emptyMessage}</p>
                            <p class="text-xs text-muted">Commencez par ajouter votre premi√®re t√¢che !</p>
                        </div>
                    `;
                    return;
                }

                // Virtual scrolling pour les grandes listes
                if (filteredTasks.length > 50) {
                    this.renderVirtualizedTasks(filteredTasks, container);
                } else {
                    this.renderRegularTasks(filteredTasks, container);
                }

                // Annoncer le nombre de t√¢ches aux lecteurs d'√©cran
                this.announceToScreenReader(`${filteredTasks.length} t√¢che${filteredTasks.length > 1 ? 's' : ''} affich√©e${filteredTasks.length > 1 ? 's' : ''}`);
            }

            renderRegularTasks(filteredTasks, container) {
                filteredTasks.forEach((task, index) => {
                    const taskElement = this.createTaskElement(task);

                    // Ajouter un d√©lai d'animation bas√© sur l'index
                    taskElement.style.animationDelay = `${index * 0.1}s`;

                    container.appendChild(taskElement);

                    // Afficher les sous-t√¢ches si elles existent
                    if (task.subtasks && task.subtasks.length > 0) {
                        task.subtasks.forEach((subtask, subIndex) => {
                            const subtaskElement = this.createSubtaskElement(subtask, task.id);
                            subtaskElement.style.animationDelay = `${(index * 0.1) + (subIndex * 0.05) + 0.05}s`;
                            container.appendChild(subtaskElement);
                        });
                    }
                });
            }

            renderVirtualizedTasks(filteredTasks, container) {
                // Impl√©mentation simplifi√©e du virtual scrolling
                const itemHeight = 80; // Hauteur estim√©e d'une t√¢che
                const containerHeight = 400;
                const visibleItems = Math.ceil(containerHeight / itemHeight);
                const totalHeight = filteredTasks.length * itemHeight;

                container.style.height = `${containerHeight}px`;
                container.style.overflowY = 'auto';
                container.style.position = 'relative';

                const virtualContainer = document.createElement('div');
                virtualContainer.style.height = `${totalHeight}px`;
                virtualContainer.style.position = 'relative';

                let startIndex = 0;
                let endIndex = Math.min(visibleItems + 5, filteredTasks.length); // Buffer de 5 √©l√©ments

                const renderVisibleItems = () => {
                    virtualContainer.innerHTML = '';

                    for (let i = startIndex; i < endIndex; i++) {
                        const task = filteredTasks[i];
                        const taskElement = this.createTaskElement(task);
                        taskElement.style.position = 'absolute';
                        taskElement.style.top = `${i * itemHeight}px`;
                        taskElement.style.width = '100%';
                        virtualContainer.appendChild(taskElement);
                    }
                };

                container.appendChild(virtualContainer);
                renderVisibleItems();

                // G√©rer le scroll pour le virtual scrolling
                container.addEventListener('scroll', this.throttle(() => {
                    const scrollTop = container.scrollTop;
                    const newStartIndex = Math.floor(scrollTop / itemHeight);
                    const newEndIndex = Math.min(newStartIndex + visibleItems + 5, filteredTasks.length);

                    if (newStartIndex !== startIndex || newEndIndex !== endIndex) {
                        startIndex = newStartIndex;
                        endIndex = newEndIndex;
                        renderVisibleItems();
                    }
                }, 16)); // 60fps
            }

            sortTasks(tasks) {
                return tasks.sort((a, b) => {
                    // T√¢ches non termin√©es en premier
                    if (a.completed !== b.completed) {
                        return a.completed ? 1 : -1;
                    }

                    // Puis par priorit√©
                    const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };
                    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
                    if (priorityDiff !== 0) return priorityDiff;

                    // Puis par date d'√©ch√©ance
                    if (a.dueDate && b.dueDate) {
                        return new Date(a.dueDate) - new Date(b.dueDate);
                    }
                    if (a.dueDate) return -1;
                    if (b.dueDate) return 1;

                    // Enfin par date de cr√©ation (plus r√©cent en premier)
                    return new Date(b.createdAt) - new Date(a.createdAt);
                });
            }

            createTaskElement(task) {
                const div = document.createElement('div');
                let className = 'task-item animate-fade-in';

                // Ajouter la classe blocked si la t√¢che est bloqu√©e par des d√©pendances
                if (!task.completed && !this.canCompleteTask(task)) {
                    className += ' blocked';
                }

                div.className = className;
                div.dataset.taskId = task.id;

                const priorityIcon = this.getPriorityIcon(task.priority);
                const priorityClass = `priority-${task.priority}`;
                const dueDateInfo = this.getDueDateInfo(task.dueDate);
                const categoryInfo = this.getCategoryInfo(task.category);

                div.innerHTML = `
                    <div class="task-content">
                        <div class="task-checkbox-container">
                            <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''}
                                   onchange="app.toggleTask('${task.id}')">
                        </div>
                        <div class="task-main">
                            <div class="task-header">
                                <span class="task-priority ${priorityClass}" title="Priorit√© ${task.priority}">
                                    ${priorityIcon}
                                </span>
                                <span class="task-title ${task.completed ? 'completed' : ''}">${task.title}</span>
                                ${categoryInfo}
                            </div>
                            ${task.description ? `<div class="task-description">${task.description}</div>` : ''}
                            ${dueDateInfo}
                            ${task.timeRange ? `<div class="task-time-range"><i class="fas fa-clock"></i> ${task.timeRange}</div>` : ''}
                            ${task.subtasks.length > 0 ? `<div class="task-subtasks-count">${task.subtasks.filter(st => st.completed).length}/${task.subtasks.length} sous-t√¢ches</div>` : ''}
                            ${task.dependencies.length > 0 ? `<div class="task-dependencies"><i class="fas fa-link"></i> ${task.dependencies.length} d√©pendance(s)</div>` : ''}
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="btn-icon" onclick="app.addSubtask('${task.id}')" title="Ajouter sous-t√¢che"><i class="fas fa-plus"></i></button>
                        <button class="btn-icon" onclick="app.manageDependencies('${task.id}')" title="G√©rer d√©pendances"><i class="fas fa-link"></i></button>
                        <button class="btn-icon" onclick="app.toggleFavorite('${task.id}')" title="Favoris">
                            <i class="fas ${task.favorite ? 'fa-star' : 'fa-star'}" style="color: ${task.favorite ? '#f59e0b' : '#94a3b8'}"></i>
                        </button>
                        <button class="btn-icon" onclick="app.editTask('${task.id}')" title="Modifier"><i class="fas fa-edit"></i></button>
                        <button class="btn-icon" onclick="app.duplicateTask('${task.id}')" title="Dupliquer"><i class="fas fa-copy"></i></button>
                        <button class="btn-icon" onclick="app.deleteTask('${task.id}')" title="Supprimer"><i class="fas fa-trash"></i></button>
                    </div>
                `;

                // Ajouter les √©v√©nements de glisser-d√©poser
                div.draggable = true;
                div.addEventListener('dragstart', (e) => this.handleDragStart(e, task));
                div.addEventListener('dragover', (e) => this.handleDragOver(e));
                div.addEventListener('drop', (e) => this.handleDrop(e, task));

                return div;
            }

            getPriorityIcon(priority) {
                const icons = {
                    critical: 'üî¥',
                    high: 'üü†',
                    normal: 'üîµ',
                    low: 'üü¢'
                };
                return icons[priority] || icons.normal;
            }

            getDueDateInfo(dueDate) {
                if (!dueDate) return '';

                const due = new Date(dueDate);
                const now = new Date();
                const diffDays = Math.ceil((due - now) / (1000 * 60 * 60 * 24));

                let dueDateClass = 'due-date';
                let dueDateText = due.toLocaleDateString('fr-FR');

                if (diffDays < 0) {
                    dueDateClass += ' overdue';
                    dueDateText = `En retard (${Math.abs(diffDays)} jours)`;
                } else if (diffDays === 0) {
                    dueDateClass += ' due-today';
                    dueDateText = 'Aujourd\'hui';
                } else if (diffDays === 1) {
                    dueDateClass += ' due-tomorrow';
                    dueDateText = 'Demain';
                } else if (diffDays <= 7) {
                    dueDateClass += ' due-soon';
                }

                return `<div class="${dueDateClass}">üìÖ ${dueDateText}</div>`;
            }

            getCategoryInfo(categoryId) {
                if (!categoryId) return '';
                const category = this.state.categories.find(c => c.id === categoryId);
                if (!category) return '';

                return `<span class="task-category" style="background-color: ${category.color}20; color: ${category.color}; border: 1px solid ${category.color}40;">
                    ${category.name}
                </span>`;
            }

            toggleTask(id) {
                const task = this.state.tasks.find(t => t.id === id);
                if (task) {
                    const taskElement = document.querySelector(`[data-task-id="${id}"]`);

                    // V√©rifier les d√©pendances avant de marquer comme termin√©e
                    if (!task.completed && !this.canCompleteTask(task)) {
                        const blockedBy = task.dependencies
                            .map(depId => this.state.tasks.find(t => t.id === depId))
                            .filter(depTask => depTask && !depTask.completed)
                            .map(depTask => depTask.title);

                        this.showNotification(`T√¢che bloqu√©e par: ${blockedBy.join(', ')}`, 'warning');
                        return;
                    }

                    task.completed = !task.completed;
                    task.updatedAt = new Date().toISOString();

                    if (task.completed) {
                        task.completedAt = new Date().toISOString();
                taskElement.classList.add('completing');

                // Animation de c√©l√©bration plus discr√®te
                setTimeout(() => {
                    taskElement.classList.add('celebrating');
                    setTimeout(() => {
                        taskElement.classList.remove('celebrating');
                    }, 800);
                }, 200);                        // Ajouter des points de gamification
                        this.addPoints(this.calculateTaskPoints(task));

                        // Cr√©er une nouvelle t√¢che r√©currente si n√©cessaire
                        if (task.recurring) {
                            setTimeout(() => {
                                this.createRecurringTask(task);
                            }, 1000);
                        }
                    } else {
                        delete task.completedAt;
                    }

                    setTimeout(() => {
                        taskElement.classList.remove('completing');
                        this.saveState();
                        this.render();
                    }, 500);
                }
            }

            deleteTask(id) {
                const taskElement = document.querySelector(`[data-task-id="${id}"]`);
                const task = this.state.tasks.find(t => t.id === id);
                
                if (taskElement) {
                    taskElement.classList.add('deleting');
                }

                setTimeout(() => {
                    this.state.tasks = this.state.tasks.filter(t => t.id !== id);
                    this.saveState();
                    this.render();
                    this.showNotification('T√¢che supprim√©e', 'info');
                }, 300);
            }

            duplicateTask(id) {
                const originalTask = this.state.tasks.find(t => t.id === id);
                if (originalTask) {
                    const duplicatedTask = {
                        ...originalTask,
                        id: Date.now().toString(),
                        title: `${originalTask.title} (copie)`,
                        completed: false,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };

                    delete duplicatedTask.completedAt;

                    this.state.tasks.unshift(duplicatedTask);
                    this.saveState();
                    this.render();
                    this.showNotification('T√¢che dupliqu√©e', 'success');
                }
            }

            toggleFavorite(id) {
                const task = this.state.tasks.find(t => t.id === id);
                if (task) {
                    task.favorite = !task.favorite;
                    task.updatedAt = new Date().toISOString();
                    this.saveState();
                    this.render();
                    this.showNotification(task.favorite ? 'Ajout√© aux favoris ‚≠ê' : 'Retir√© des favoris', 'info');
                }
            }

            async editTask(id) {
                const task = this.state.tasks.find(t => t.id === id);
                if (task) {
                    const newTitle = await this.prompt('Modifier le titre de la t√¢che:', task.title, 'Modifier la t√¢che');
                    if (newTitle && newTitle.trim() !== task.title) {
                        task.title = newTitle.trim();
                        task.updatedAt = new Date().toISOString();
                        this.saveState();
                        this.render();
                        this.showNotification('T√¢che modifi√©e', 'success');
                    }
                }
            }

            calculateTaskPoints(task) {
                let points = 10; // Points de base

                // Bonus selon la priorit√©
                const priorityBonus = {
                    critical: 50,
                    high: 30,
                    normal: 10,
                    low: 5
                };
                points += priorityBonus[task.priority] || 10;

                // Bonus pour les sous-t√¢ches
                points += task.subtasks.length * 5;

                // Bonus si termin√© √† temps
                if (task.dueDate && new Date(task.dueDate) >= new Date()) {
                    points += 20;
                }

                return points;
            }

            addPoints(points) {
                if (!this.state.gamification) {
                    this.state.gamification = {
                        totalPoints: 0,
                        level: 1,
                        badges: [],
                        achievements: [],
                        streakRecord: 0
                    };
                }

                const oldLevel = this.state.gamification.level;
                this.state.gamification.totalPoints += points;

                // Calcul du niveau (100 points par niveau)
                const newLevel = Math.floor(this.state.gamification.totalPoints / 100) + 1;
                if (newLevel > this.state.gamification.level) {
                    this.state.gamification.level = newLevel;
                    this.showNotification(`Niveau ${newLevel} atteint ! üéä`, 'success');
                    this.checkForNewBadges();
                }

                // V√©rifier les nouveaux badges
                this.checkForNewBadges();
            }

            checkForNewBadges() {
                const badges = this.getAvailableBadges();
                const currentBadges = this.state.gamification.badges || [];

                badges.forEach(badge => {
                    if (!currentBadges.find(b => b.id === badge.id) && badge.condition()) {
                        currentBadges.push({
                            ...badge,
                            earnedAt: new Date().toISOString(),
                            isNew: true
                        });

                        this.showNotification(`Nouveau badge d√©bloqu√©: ${badge.name} ${badge.icon}`, 'success');

                        // Retirer le flag "nouveau" apr√®s 5 secondes
                        setTimeout(() => {
                            const badgeIndex = currentBadges.findIndex(b => b.id === badge.id);
                            if (badgeIndex !== -1) {
                                currentBadges[badgeIndex].isNew = false;
                                this.saveState();
                            }
                        }, 5000);
                    }
                });

                this.state.gamification.badges = currentBadges;
            }

            getAvailableBadges() {
                const stats = this.calculateStats();
                const streak = this.calculateStreak();
                const totalCompleted = this.state.tasks.filter(t => t.completed).length;
                const highPriorityCompleted = this.state.tasks.filter(t =>
                    t.completed && (t.priority === 'high' || t.priority === 'critical')
                ).length;

                return [
                    {
                        id: 'first_task',
                        name: 'Premier pas',
                        description: 'Terminez votre premi√®re t√¢che',
                        icon: 'üéØ',
                        condition: () => totalCompleted >= 1
                    },
                    {
                        id: 'task_master_10',
                        name: 'Ma√Ætre des t√¢ches',
                        description: 'Terminez 10 t√¢ches',
                        icon: 'üèÖ',
                        condition: () => totalCompleted >= 10
                    },
                    {
                        id: 'task_master_50',
                        name: 'Expert productivit√©',
                        description: 'Terminez 50 t√¢ches',
                        icon: 'üèÜ',
                        condition: () => totalCompleted >= 50
                    },
                    {
                        id: 'task_master_100',
                        name: 'L√©gende',
                        description: 'Terminez 100 t√¢ches',
                        icon: 'üíé',
                        condition: () => totalCompleted >= 100
                    },
                    {
                        id: 'streak_3',
                        name: 'R√©gularit√©',
                        description: 'Maintenez une s√©rie de 3 jours',
                        icon: 'üî•',
                        condition: () => streak >= 3
                    },
                    {
                        id: 'streak_7',
                        name: 'Pers√©v√©rance',
                        description: 'Maintenez une s√©rie de 7 jours',
                        icon: '‚ö°',
                        condition: () => streak >= 7
                    },
                    {
                        id: 'streak_30',
                        name: 'Discipline de fer',
                        description: 'Maintenez une s√©rie de 30 jours',
                        icon: 'üëë',
                        condition: () => streak >= 30
                    },
                    {
                        id: 'priority_master',
                        name: 'Ma√Ætre des priorit√©s',
                        description: 'Terminez 20 t√¢ches de haute priorit√©',
                        icon: 'üéØ',
                        condition: () => highPriorityCompleted >= 20
                    },
                    {
                        id: 'organizer',
                        name: 'Organisateur',
                        description: 'Cr√©ez 5 cat√©gories',
                        icon: 'üìÇ',
                        condition: () => this.state.categories.length >= 5
                    },
                    {
                        id: 'pomodoro_master',
                        name: 'Ma√Ætre Pomodoro',
                        description: 'Terminez 10 sessions Pomodoro',
                        icon: 'üçÖ',
                        condition: () => (this.state.totalPomodoroSessions || 0) >= 10
                    },
                    {
                        id: 'early_bird',
                        name: 'L√®ve-t√¥t',
                        description: 'Terminez une t√¢che avant 8h',
                        icon: 'üåÖ',
                        condition: () => this.state.tasks.some(task => {
                            if (!task.completed || !task.completedAt) return false;
                            const completedTime = new Date(task.completedAt);
                            return completedTime.getHours() < 8;
                        })
                    },
                    {
                        id: 'night_owl',
                        name: 'Couche-tard',
                        description: 'Terminez une t√¢che apr√®s 22h',
                        icon: 'ü¶â',
                        condition: () => this.state.tasks.some(task => {
                            if (!task.completed || !task.completedAt) return false;
                            const completedTime = new Date(task.completedAt);
                            return completedTime.getHours() >= 22;
                        })
                    }
                ];
            }

            // Fonctions de drag and drop
            handleDragStart(e, task) {
                e.dataTransfer.setData('text/plain', task.id);
                e.target.classList.add('dragging');
            }

            handleDragOver(e) {
                e.preventDefault();
                e.target.closest('.task-item')?.classList.add('drag-over');
            }

            handleDrop(e, targetTask) {
                e.preventDefault();
                const draggedTaskId = e.dataTransfer.getData('text/plain');
                const draggedTask = this.state.tasks.find(t => t.id === draggedTaskId);

                if (draggedTask && draggedTask.id !== targetTask.id) {
                    // R√©organiser les t√¢ches
                    const draggedIndex = this.state.tasks.indexOf(draggedTask);
                    const targetIndex = this.state.tasks.indexOf(targetTask);

                    this.state.tasks.splice(draggedIndex, 1);
                    this.state.tasks.splice(targetIndex, 0, draggedTask);

                    this.saveState();
                    this.render();
                    this.showNotification('T√¢che d√©plac√©e', 'info');
                }

                // Nettoyer les classes
                document.querySelectorAll('.task-item').forEach(item => {
                    item.classList.remove('dragging', 'drag-over');
                });
            }

            renderStats() {
                const total = this.state.tasks.length;
                const completed = this.state.tasks.filter(t => t.completed).length;
                const pending = total - completed;
                const overdue = this.state.tasks.filter(t =>
                    t.dueDate && new Date(t.dueDate) < new Date() && !t.completed
                ).length;

                let statsHtml = `<span class="text-sm text-muted">${total} t√¢ches`;
                if (completed > 0) statsHtml += ` ‚Ä¢ ${completed} termin√©es`;
                if (overdue > 0) statsHtml += ` ‚Ä¢ <span style="color: var(--danger-color)">${overdue} en retard</span>`;
                statsHtml += '</span>';

                // Ajouter les points de gamification si disponibles
                if (this.state.gamification) {
                    const currentXP = this.state.gamification.totalPoints % 100;
                    const nextLevelXP = 100;

                    statsHtml += ` ‚Ä¢ <span class="level-indicator">
                        ‚≠ê Niveau ${this.state.gamification.level}
                        <div class="xp-bar">
                            <div class="xp-progress" style="width: ${(currentXP / nextLevelXP) * 100}%"></div>
                        </div>
                    </span>`;

                    // Afficher les badges r√©cents
                    const recentBadges = (this.state.gamification.badges || [])
                        .filter(badge => badge.isNew)
                        .slice(0, 2);

                    if (recentBadges.length > 0) {
                        statsHtml += '<br><div style="margin-top: 4px;">';
                        recentBadges.forEach(badge => {
                            statsHtml += `<span class="badge new">${badge.icon} ${badge.name}</span>`;
                        });
                        statsHtml += '</div>';
                    }
                }

                document.getElementById('stats-summary').innerHTML = statsHtml;
            }

            // Fonction de recherche
            searchTasks(query) {
                const searchTerm = query.toLowerCase();
                return this.state.tasks.filter(task =>
                    task.title.toLowerCase().includes(searchTerm) ||
                    (task.description && task.description.toLowerCase().includes(searchTerm)) ||
                    task.tags.some(tag => tag.toLowerCase().includes(searchTerm))
                );
            }

            // Fonction de filtrage
            filterTasks(filter) {
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);

                switch (filter) {
                    case 'today':
                        return this.state.tasks.filter(task => {
                            if (!task.dueDate) return false;
                            const dueDate = new Date(task.dueDate);
                            return dueDate >= today && dueDate < tomorrow;
                        });
                    case 'upcoming':
                        return this.state.tasks.filter(task => {
                            if (!task.dueDate) return false;
                            return new Date(task.dueDate) > tomorrow;
                        });
                    case 'overdue':
                        return this.state.tasks.filter(task => {
                            if (!task.dueDate || task.completed) return false;
                            return new Date(task.dueDate) < today;
                        });
                    case 'completed':
                        return this.state.tasks.filter(task => task.completed);
                    case 'favorites':
                        return this.state.tasks.filter(task => task.favorite);
                    case 'high-priority':
                        return this.state.tasks.filter(task => task.priority === 'high' || task.priority === 'critical');
                    case 'category':
                        // Le filtrage par cat√©gorie sp√©cifique est g√©r√© dans renderTasks
                        return this.state.tasks;
                    case 'date':
                        // Filtrage par date s√©lectionn√©e dans le calendrier
                        if (this.state.selectedDate) {
                            return this.state.tasks.filter(task => task.dueDate === this.state.selectedDate);
                        }
                        return this.state.tasks;
                    case 'search':
                        // Filtrage par recherche
                        if (this.state.searchQuery) {
                            return this.searchTasks(this.state.searchQuery);
                        }
                        return this.state.tasks;
                    default:
                        return this.state.tasks;
                }
            }

            // Initialisation des cat√©gories par d√©faut
            initDefaultCategories() {
                if (this.state.categories.length === 0) {
                    const defaultCategories = [
                        { id: 'work', name: 'Travail', color: '#3b82f6' },
                        { id: 'personal', name: 'Personnel', color: '#10b981' },
                        { id: 'shopping', name: 'Courses', color: '#f59e0b' },
                        { id: 'health', name: 'Sant√©', color: '#ef4444' }
                    ];

                    defaultCategories.forEach(cat => {
                        cat.id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
                        cat.createdAt = new Date().toISOString();
                    });

                    this.state.categories = defaultCategories;
                    this.saveState();
                }
            }

            // Initialisation du calendrier
            initCalendar() {
                // S'assurer que le calendrier affiche toujours le mois actuel
                this.state.calendarDate = new Date();
                this.saveState();
            }

            // Gestion du calendrier
            renderMiniCalendar() {
                const calendarContainer = document.getElementById('mini-calendar');
                if (!calendarContainer) return;

                // S'assurer que la date du calendrier est toujours d√©finie sur aujourd'hui par d√©faut
                if (!this.state.calendarDate) {
                    this.state.calendarDate = new Date();
                }
                const currentDate = new Date(this.state.calendarDate);

                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const startDate = new Date(firstDay);
                startDate.setDate(startDate.getDate() - firstDay.getDay());

                const monthNames = [
                    'Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
                    'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'
                ];

                const dayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];

                let calendarHTML = `
                    <div class="calendar-header">
                        <button class="calendar-nav" onclick="app.changeCalendarMonth(-1)">‚Äπ</button>
                        <div class="calendar-month">${monthNames[month]} ${year}</div>
                        <button class="calendar-nav" onclick="app.changeCalendarMonth(1)">‚Ä∫</button>
                    </div>
                    <div class="calendar-controls">
                        <button class="btn btn-secondary text-xs" onclick="app.goToToday()" title="Aller √† aujourd'hui">Aujourd'hui</button>
                    </div>
                    <div class="calendar-grid">
                `;

                // En-t√™tes des jours
                dayNames.forEach(day => {
                    calendarHTML += `<div class="calendar-day-header">${day}</div>`;
                });

                // Jours du calendrier
                const today = new Date();
                for (let i = 0; i < 42; i++) {
                    const date = new Date(startDate);
                    date.setDate(startDate.getDate() + i);

                    const isToday = date.toDateString() === today.toDateString();
                    const isCurrentMonth = date.getMonth() === month;
                    const hasTasks = this.getTasksForDate(date).length > 0;

                    let dayClass = 'calendar-day';
                    if (isToday) dayClass += ' today';
                    if (!isCurrentMonth) dayClass += ' other-month';
                    if (hasTasks) dayClass += ' has-tasks';

                    calendarHTML += `
                        <div class="${dayClass}" onclick="app.selectCalendarDate('${date.toISOString()}')">
                            ${date.getDate()}
                        </div>
                    `;
                }

                calendarHTML += '</div>';
                calendarContainer.innerHTML = calendarHTML;
            }

            changeCalendarMonth(direction) {
                const currentDate = this.state.calendarDate ? new Date(this.state.calendarDate) : new Date();
                currentDate.setMonth(currentDate.getMonth() + direction);
                this.state.calendarDate = currentDate;
                this.renderMiniCalendar();
                this.saveState();
            }

            goToToday() {
                this.state.calendarDate = new Date();
                this.renderMiniCalendar();
                this.saveState();
                this.showNotification('Calendrier mis √† jour sur aujourd\'hui', 'info');
            }

            selectCalendarDate(dateString) {
                const selectedDate = new Date(dateString);
                this.state.selectedDate = selectedDate.toISOString().split('T')[0];
                this.state.currentFilter = 'date';
                this.render();
                this.showNotification(`T√¢ches du ${selectedDate.toLocaleDateString('fr-FR')}`, 'info');
            }

            getTasksForDate(date) {
                const dateString = date.toISOString().split('T')[0];
                return this.state.tasks.filter(task => {
                    if (!task.dueDate) return false;
                    return task.dueDate === dateString;
                });
            }

            // Gestion des t√¢ches r√©currentes
            createRecurringTask(originalTask) {
                if (!originalTask.recurring || !originalTask.dueDate) return;

                const dueDate = new Date(originalTask.dueDate);
                let nextDate = new Date(dueDate);

                switch (originalTask.recurring) {
                    case 'daily':
                        nextDate.setDate(nextDate.getDate() + 1);
                        break;
                    case 'weekly':
                        nextDate.setDate(nextDate.getDate() + 7);
                        break;
                    case 'monthly':
                        nextDate.setMonth(nextDate.getMonth() + 1);
                        break;
                    default:
                        return;
                }

                const newTask = {
                    ...originalTask,
                    id: Date.now().toString(),
                    completed: false,
                    dueDate: nextDate.toISOString().split('T')[0],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                delete newTask.completedAt;

                this.state.tasks.unshift(newTask);
                this.saveState();
                this.showNotification('T√¢che r√©currente cr√©√©e !', 'success');
            }

            // Gestion des sous-t√¢ches
            createSubtaskElement(subtask, parentId) {
                const div = document.createElement('div');
                div.className = 'subtask-item animate-fade-in';
                div.dataset.subtaskId = subtask.id;
                div.dataset.parentId = parentId;

                div.innerHTML = `
                    <div class="subtask-content">
                        <div class="subtask-indent"></div>
                        <div class="task-checkbox-container">
                            <input type="checkbox" class="task-checkbox" ${subtask.completed ? 'checked' : ''}
                                   onchange="app.toggleSubtask('${parentId}', '${subtask.id}')">
                        </div>
                        <div class="subtask-main">
                            <span class="task-title ${subtask.completed ? 'completed' : ''}">${subtask.title}</span>
                            ${subtask.description ? `<div class="task-description">${subtask.description}</div>` : ''}
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="btn-icon" onclick="app.editSubtask('${parentId}', '${subtask.id}')" title="Modifier">‚úèÔ∏è</button>
                        <button class="btn-icon" onclick="app.deleteSubtask('${parentId}', '${subtask.id}')" title="Supprimer">üóëÔ∏è</button>
                    </div>
                `;

                return div;
            }

            async addSubtask(parentId) {
                const title = await this.prompt('Titre de la sous-t√¢che:', '', 'Nouvelle sous-t√¢che');
                if (title && title.trim()) {
                    const parentTask = this.state.tasks.find(t => t.id === parentId);
                    if (parentTask) {
                        const subtask = {
                            id: Date.now().toString(),
                            title: title.trim(),
                            description: '',
                            completed: false,
                            createdAt: new Date().toISOString()
                        };

                        if (!parentTask.subtasks) {
                            parentTask.subtasks = [];
                        }

                        parentTask.subtasks.push(subtask);
                        parentTask.updatedAt = new Date().toISOString();

                        this.saveState();
                        this.render();
                        this.showNotification('Sous-t√¢che ajout√©e !', 'success');
                    }
                }
            }

            toggleSubtask(parentId, subtaskId) {
                const parentTask = this.state.tasks.find(t => t.id === parentId);
                if (parentTask) {
                    const subtask = parentTask.subtasks.find(st => st.id === subtaskId);
                    if (subtask) {
                        subtask.completed = !subtask.completed;
                        subtask.updatedAt = new Date().toISOString();
                        parentTask.updatedAt = new Date().toISOString();

                        // V√©rifier si toutes les sous-t√¢ches sont termin√©es
                        const allSubtasksCompleted = parentTask.subtasks.every(st => st.completed);
                        if (allSubtasksCompleted && parentTask.subtasks.length > 0) {
                            this.showNotification('Toutes les sous-t√¢ches termin√©es ! üéâ', 'success');
                        }

                        this.saveState();
                        this.render();
                    }
                }
            }

            async editSubtask(parentId, subtaskId) {
                const parentTask = this.state.tasks.find(t => t.id === parentId);
                if (parentTask) {
                    const subtask = parentTask.subtasks.find(st => st.id === subtaskId);
                    if (subtask) {
                        const newTitle = await this.prompt('Modifier le titre de la sous-t√¢che:', subtask.title, 'Modifier la sous-t√¢che');
                        if (newTitle && newTitle.trim() !== subtask.title) {
                            subtask.title = newTitle.trim();
                            subtask.updatedAt = new Date().toISOString();
                            parentTask.updatedAt = new Date().toISOString();

                            this.saveState();
                            this.render();
                            this.showNotification('Sous-t√¢che modifi√©e', 'success');
                        }
                    }
                }
            }

            async deleteSubtask(parentId, subtaskId) {
                const confirmed = await this.confirm('Supprimer cette sous-t√¢che ?', 'Supprimer la sous-t√¢che');
                if (confirmed) {
                    const parentTask = this.state.tasks.find(t => t.id === parentId);
                    if (parentTask) {
                        parentTask.subtasks = parentTask.subtasks.filter(st => st.id !== subtaskId);
                        parentTask.updatedAt = new Date().toISOString();

                        this.saveState();
                        this.render();
                        this.showNotification('Sous-t√¢che supprim√©e', 'info');
                    }
                }
            }

            // Gestion des d√©pendances
            async manageDependencies(taskId) {
                const task = this.state.tasks.find(t => t.id === taskId);
                if (!task) return;

                const availableTasks = this.state.tasks.filter(t =>
                    t.id !== taskId && !t.completed && !this.hasDependencyLoop(taskId, t.id)
                );

                if (availableTasks.length === 0) {
                    this.alert('Aucune t√¢che disponible pour cr√©er une d√©pendance.', 'D√©pendances');
                    return;
                }

                let options = 'T√¢ches disponibles:\n';
                availableTasks.forEach((t, index) => {
                    options += `${index + 1}. ${t.title}\n`;
                });

                const choice = await this.prompt(options + '\n\nEntrez le num√©ro de la t√¢che dont cette t√¢che d√©pend (0 pour annuler):', '', 'Ajouter une d√©pendance');
                const choiceNum = parseInt(choice);

                if (choiceNum > 0 && choiceNum <= availableTasks.length) {
                    const dependencyTask = availableTasks[choiceNum - 1];

                    if (!task.dependencies) {
                        task.dependencies = [];
                    }

                    if (!task.dependencies.includes(dependencyTask.id)) {
                        task.dependencies.push(dependencyTask.id);
                        task.updatedAt = new Date().toISOString();

                        this.saveState();
                        this.render();
                        this.showNotification(`D√©pendance ajout√©e: ${dependencyTask.title}`, 'success');
                    } else {
                        this.showNotification('Cette d√©pendance existe d√©j√†', 'info');
                    }
                }
            }

            hasDependencyLoop(taskId, dependencyId) {
                // V√©rifier s'il y aurait une boucle de d√©pendances
                const dependencyTask = this.state.tasks.find(t => t.id === dependencyId);
                if (!dependencyTask || !dependencyTask.dependencies) return false;

                return dependencyTask.dependencies.includes(taskId) ||
                    dependencyTask.dependencies.some(depId => this.hasDependencyLoop(taskId, depId));
            }

            canCompleteTask(task) {
                // V√©rifier si toutes les d√©pendances sont termin√©es
                if (!task.dependencies || task.dependencies.length === 0) return true;

                return task.dependencies.every(depId => {
                    const depTask = this.state.tasks.find(t => t.id === depId);
                    return depTask && depTask.completed;
                });
            }

            getBlockedTasks() {
                // Retourner les t√¢ches bloqu√©es par des d√©pendances
                return this.state.tasks.filter(task =>
                    !task.completed && !this.canCompleteTask(task)
                );
            }

            // Fonctionnalit√©s de productivit√©

            // Recherche avanc√©e
            handleSearch(e) {
                const query = e.target.value.trim();
                this.searchDebounce(query);
            }

            performSearch(query) {
                this.state.searchQuery = query;

                if (query) {
                    this.state.currentFilter = 'search';
                    this.announceToScreenReader(`${this.searchTasks(query).length} r√©sultats trouv√©s pour "${query}"`);
                } else {
                    this.state.currentFilter = 'all';
                }

                this.render();
            }

            clearSearch() {
                document.getElementById('search-input').value = '';
                this.state.searchQuery = '';
                this.state.currentFilter = 'all';
                this.render();
            }

            // Timer Pomodoro
            togglePomodoroTimer() {
                if (!this.state.pomodoro) {
                    this.state.pomodoro = {
                        isRunning: false,
                        timeLeft: 25 * 60, // 25 minutes en secondes
                        isBreak: false,
                        interval: null
                    };
                }

                const pomodoro = this.state.pomodoro;
                const timerElement = document.getElementById('pomodoro-timer');
                const toggleBtn = document.getElementById('timer-toggle');

                if (pomodoro.isRunning) {
                    // Arr√™ter le timer
                    clearInterval(pomodoro.interval);
                    pomodoro.isRunning = false;
                    toggleBtn.innerHTML = '<i class="fas fa-play"></i>';
                    timerElement.classList.remove('active');
                    this.showNotification('Timer en pause', 'info');
                } else {
                    // D√©marrer le timer
                    pomodoro.isRunning = true;
                    toggleBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    timerElement.classList.add('active');

                    pomodoro.interval = setInterval(() => {
                        pomodoro.timeLeft--;
                        this.updateTimerDisplay();

                        if (pomodoro.timeLeft <= 0) {
                            this.pomodoroComplete();
                        }
                    }, 1000);

                    this.showNotification('Timer Pomodoro d√©marr√© !', 'success');
                }
            }

            updateTimerDisplay() {
                const pomodoro = this.state.pomodoro;
                const minutes = Math.floor(pomodoro.timeLeft / 60);
                const seconds = pomodoro.timeLeft % 60;
                const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                document.getElementById('timer-display').textContent = display;

                // Changer le titre de la page pour afficher le timer
                if (pomodoro.isRunning) {
                    document.title = `${display} - TodoList Pro`;
                } else {
                    document.title = 'TodoList Pro';
                }
            }

            pomodoroComplete() {
                const pomodoro = this.state.pomodoro;
                clearInterval(pomodoro.interval);
                pomodoro.isRunning = false;

                const toggleBtn = document.getElementById('timer-toggle');
                const timerElement = document.getElementById('pomodoro-timer');

                toggleBtn.innerHTML = '<i class="fas fa-play"></i>';
                timerElement.classList.remove('active');

                if (pomodoro.isBreak) {
                    // Fin de la pause, retour au travail
                    pomodoro.timeLeft = 25 * 60;
                    pomodoro.isBreak = false;
                    this.showNotification('Pause termin√©e ! Retour au travail üí™', 'success');
                } else {
                    // Fin du travail, d√©but de la pause
                    pomodoro.timeLeft = 5 * 60; // 5 minutes de pause
                    pomodoro.isBreak = true;
                    this.showNotification('Pomodoro termin√© ! Prenez une pause ‚òï', 'success');

                    // Compter les sessions Pomodoro
                    this.state.totalPomodoroSessions = (this.state.totalPomodoroSessions || 0) + 1;
                    this.state.pomodoroSessionsToday = (this.state.pomodoroSessionsToday || 0) + 1;

                    // Ajouter des points de gamification
                    this.addPoints(50);
                }

                this.updateTimerDisplay();
                document.title = 'TodoList Pro';
            }

            // Mode Focus
            toggleFocusMode() {
                document.body.classList.toggle('focus-mode');
                const isActive = document.body.classList.contains('focus-mode');

                if (isActive) {
                    this.showNotification('Mode Focus activ√©', 'success');
                    document.getElementById('focus-mode-toggle').innerHTML = '<i class="fas fa-arrow-left"></i>';
                } else {
                    this.showNotification('Mode Focus d√©sactiv√©', 'info');
                    document.getElementById('focus-mode-toggle').innerHTML = '<i class="fas fa-bullseye"></i>';
                }
            }

            // Syst√®me de th√®mes et personnalisation

            showSettings() {
                const settingsHTML = `
                    <div class="modal-content" style="max-width: 500px; margin: 50px auto; background: var(--bg-primary); padding: var(--spacing-xl); border-radius: var(--border-radius-lg); box-shadow: var(--shadow-lg);">
                        <h2 style="margin-bottom: var(--spacing-lg);">‚öôÔ∏è Param√®tres</h2>

                        <div class="settings-section">
                            <h3>üé® Th√®mes</h3>
                            <div class="theme-selector" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: var(--spacing-md); margin: var(--spacing-md) 0;">
                                <button class="theme-btn ${this.state.theme === 'light' ? 'active' : ''}" onclick="app.setTheme('light')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: var(--border-radius); background: white; cursor: pointer;">
                                    ‚òÄÔ∏è Clair
                                </button>
                                <button class="theme-btn ${this.state.theme === 'dark' ? 'active' : ''}" onclick="app.setTheme('dark')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: var(--border-radius); background: #1e293b; color: white; cursor: pointer;">
                                    üåô Sombre
                                </button>
                                <button class="theme-btn ${this.state.theme === 'colorful' ? 'active' : ''}" onclick="app.setTheme('colorful')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: var(--border-radius); background: linear-gradient(45deg, #667eea, #764ba2); color: white; cursor: pointer;">
                                    üåà Color√©
                                </button>
                                <button class="theme-btn ${this.state.theme === 'minimal' ? 'active' : ''}" onclick="app.setTheme('minimal')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: 0; background: #fafafa; cursor: pointer;">
                                    ‚ö™ Minimal
                                </button>
                                <button class="theme-btn ${this.state.theme === 'nature' ? 'active' : ''}" onclick="app.setTheme('nature')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: var(--border-radius); background: linear-gradient(45deg, #a8e6cf, #dcedc1); cursor: pointer;">
                                    üåø Nature
                                </button>
                            </div>
                        </div>

                        <div class="settings-section" style="margin-top: var(--spacing-lg);">
                            <h3>üßò Modes sp√©ciaux</h3>
                            <div style="margin: var(--spacing-md) 0;">
                                <button class="btn ${document.body.classList.contains('zen-mode') ? 'btn-primary' : 'btn-secondary'}" onclick="app.toggleZenMode()">
                                    üßò Mode Zen
                                </button>
                                <button class="btn ${document.body.classList.contains('focus-mode') ? 'btn-primary' : 'btn-secondary'}" onclick="app.toggleFocusMode()" style="margin-left: var(--spacing-sm);">
                                    üéØ Mode Focus
                                </button>
                            </div>
                        </div>

                        <div class="settings-section" style="margin-top: var(--spacing-lg);">
                            <h3>üìä Donn√©es</h3>
                            <div style="margin: var(--spacing-md) 0;">
                                <button class="btn btn-secondary" onclick="app.exportData()">
                                    üì§ Exporter les donn√©es
                                </button>
                                <button class="btn btn-secondary" onclick="app.importData()" style="margin-left: var(--spacing-sm);">
                                    üì• Importer les donn√©es
                                </button>
                                <button class="btn" onclick="app.resetData()" style="margin-left: var(--spacing-sm); background: var(--danger-color); color: white;">
                                    üóëÔ∏è R√©initialiser
                                </button>
                            </div>
                        </div>

                        <div style="margin-top: var(--spacing-xl); text-align: center;">
                            <button class="btn btn-primary" onclick="app.closeSettings()">
                                Fermer
                            </button>
                        </div>
                    </div>
                `;

                const overlay = document.getElementById('modal-overlay');
                overlay.innerHTML = settingsHTML;
                overlay.classList.remove('hidden');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
            }

            closeSettings() {
                document.getElementById('modal-overlay').classList.add('hidden');
            }

            toggleZenMode() {
                document.body.classList.toggle('zen-mode');
                const isActive = document.body.classList.contains('zen-mode');

                if (isActive) {
                    this.showNotification('Mode Zen activ√© üßò', 'success');
                } else {
                    this.showNotification('Mode Zen d√©sactiv√©', 'info');
                }

                this.closeSettings();
            }

            exportData() {
                const data = {
                    tasks: this.state.tasks,
                    categories: this.state.categories,
                    settings: this.state.settings,
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `todolist-backup-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.showNotification('Donn√©es export√©es !', 'success');
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const data = JSON.parse(e.target.result);
                                if (data.tasks && data.categories) {
                                    this.state.tasks = data.tasks;
                                    this.state.categories = data.categories;
                                    if (data.settings) this.state.settings = data.settings;

                                    this.saveState();
                                    this.render();
                                    this.showNotification('Donn√©es import√©es !', 'success');
                                    this.closeSettings();
                                } else {
                                    throw new Error('Format invalide');
                                }
                            } catch (error) {
                                this.showNotification('Erreur lors de l\'importation', 'error');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }

            async resetData() {
                const confirmed = await this.confirm('√ätes-vous s√ªr de vouloir supprimer toutes les donn√©es ? Cette action est irr√©versible.', 'R√©initialiser les donn√©es');
                if (confirmed) {
                    this.state.tasks = [];
                    this.state.categories = [];
                    this.state.settings = {};
                    this.initDefaultCategories();
                    this.saveState();
                    this.render();
                    this.showNotification('Donn√©es r√©initialis√©es', 'info');
                    this.closeSettings();
                }
            }

            // Syst√®me de statistiques et suivi

            renderStatsWidget() {
                const statsContainer = document.getElementById('stats-widget');
                if (!statsContainer) return;

                const stats = this.calculateStats();
                const streak = this.calculateStreak();

                let statsHTML = '';

                // Streak actuel
                if (streak > 0) {
                    statsHTML += `
                        <div class="stat-item">
                            <span class="stat-label">S√©rie actuelle</span>
                            <span class="streak-indicator">üî• ${streak} jour${streak > 1 ? 's' : ''}</span>
                        </div>
                    `;
                }

                // T√¢ches termin√©es aujourd'hui
                statsHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Aujourd'hui</span>
                        <span class="stat-value">${stats.todayCompleted}</span>
                    </div>
                `;

                // Taux de completion cette semaine
                const completionRate = stats.weekTotal > 0 ? Math.round((stats.weekCompleted / stats.weekTotal) * 100) : 0;
                statsHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Taux semaine</span>
                        <span class="stat-value">${completionRate}%</span>
                    </div>
                `;

                // Graphique de productivit√© des 7 derniers jours
                statsHTML += '<div class="productivity-chart" id="mini-chart"></div>';

                statsContainer.innerHTML = statsHTML;

                // G√©n√©rer le mini graphique
                this.renderMiniChart();
            }

            calculateStats() {
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const weekAgo = new Date(today);
                weekAgo.setDate(weekAgo.getDate() - 7);

                const todayCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    const completedDate = new Date(task.completedAt);
                    return completedDate >= today;
                }).length;

                const weekCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    const completedDate = new Date(task.completedAt);
                    return completedDate >= weekAgo;
                }).length;

                const weekTotal = this.state.tasks.filter(task => {
                    const createdDate = new Date(task.createdAt);
                    return createdDate >= weekAgo;
                }).length;

                return {
                    todayCompleted,
                    weekCompleted,
                    weekTotal,
                    totalTasks: this.state.tasks.length,
                    totalCompleted: this.state.tasks.filter(t => t.completed).length
                };
            }

            calculateStreak() {
                const completedDates = this.state.tasks
                    .filter(task => task.completed && task.completedAt)
                    .map(task => {
                        const date = new Date(task.completedAt);
                        return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
                    })
                    .filter((date, index, array) => array.indexOf(date) === index) // Unique dates
                    .sort((a, b) => b - a); // Most recent first

                if (completedDates.length === 0) return 0;

                const today = new Date();
                const todayTime = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
                const yesterdayTime = todayTime - (24 * 60 * 60 * 1000);

                let streak = 0;
                let currentDate = todayTime;

                // Commencer par aujourd'hui ou hier
                if (completedDates.includes(todayTime)) {
                    streak = 1;
                    currentDate = todayTime;
                } else if (completedDates.includes(yesterdayTime)) {
                    streak = 1;
                    currentDate = yesterdayTime;
                } else {
                    return 0;
                }

                // Compter les jours cons√©cutifs
                for (let i = 1; i < completedDates.length; i++) {
                    const expectedDate = currentDate - (24 * 60 * 60 * 1000);
                    if (completedDates.includes(expectedDate)) {
                        streak++;
                        currentDate = expectedDate;
                    } else {
                        break;
                    }
                }

                return streak;
            }

            renderMiniChart() {
                const chartContainer = document.getElementById('mini-chart');
                if (!chartContainer) return;

                const last7Days = [];
                const today = new Date();

                for (let i = 6; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dayStart = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                    const dayEnd = new Date(dayStart);
                    dayEnd.setDate(dayEnd.getDate() + 1);

                    const completed = this.state.tasks.filter(task => {
                        if (!task.completed || !task.completedAt) return false;
                        const completedDate = new Date(task.completedAt);
                        return completedDate >= dayStart && completedDate < dayEnd;
                    }).length;

                    last7Days.push(completed);
                }

                const maxValue = Math.max(...last7Days, 1);
                chartContainer.innerHTML = '';

                last7Days.forEach((value, index) => {
                    const bar = document.createElement('div');
                    bar.className = 'chart-bar';
                    bar.style.left = `${(index * 14.28)}%`;
                    bar.style.width = '12%';
                    bar.style.height = `${(value / maxValue) * 100}%`;
                    bar.title = `${value} t√¢che${value > 1 ? 's' : ''} termin√©e${value > 1 ? 's' : ''}`;
                    chartContainer.appendChild(bar);
                });
            }

            showDetailedStats() {
                const stats = this.calculateDetailedStats();
                const streak = this.calculateStreak();

                const statsHTML = `
                    <div class="modal-content detailed-stats-modal" style="margin: 20px auto; background: var(--bg-primary); padding: var(--spacing-xl); border-radius: var(--border-radius-lg); box-shadow: var(--shadow-lg);">
                        <h2 style="margin-bottom: var(--spacing-lg); text-align: center;">üìä Statistiques d√©taill√©es</h2>

                        <div class="stats-grid">
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.totalCompleted}</div>
                                <div class="stats-card-label">T√¢ches termin√©es</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.totalTasks}</div>
                                <div class="stats-card-label">Total des t√¢ches</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${Math.round(stats.completionRate)}%</div>
                                <div class="stats-card-label">Taux de r√©ussite</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${streak}</div>
                                <div class="stats-card-label">S√©rie actuelle (jours)</div>
                            </div>
                        </div>

                        <div class="stats-grid">
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.thisWeekCompleted}</div>
                                <div class="stats-card-label">Cette semaine</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.thisMonthCompleted}</div>
                                <div class="stats-card-label">Ce mois</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.averagePerDay.toFixed(1)}</div>
                                <div class="stats-card-label">Moyenne/jour</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.highPriorityCompleted}</div>
                                <div class="stats-card-label">Priorit√© haute termin√©es</div>
                            </div>
                        </div>

                        <h3 style="margin: var(--spacing-xl) 0 var(--spacing-md);">üìà Productivit√© par cat√©gorie</h3>
                        <div class="category-stats">
                            ${this.renderCategoryStats(stats.categoryStats)}
                        </div>

                        <h3 style="margin: var(--spacing-xl) 0 var(--spacing-md);">üèÜ R√©alisations</h3>
                        <div class="achievements">
                            ${this.renderAchievements(stats)}
                        </div>

                        <div style="margin-top: var(--spacing-xl); text-align: center;">
                            <button class="btn btn-primary" onclick="app.closeSettings()">
                                Fermer
                            </button>
                        </div>
                    </div>
                `;

                const overlay = document.getElementById('modal-overlay');
                overlay.innerHTML = statsHTML;
                overlay.classList.remove('hidden');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 1000;
                    display: flex;
                    align-items: flex-start;
                    justify-content: center;
                    overflow-y: auto;
                `;
            }

            calculateDetailedStats() {
                const now = new Date();
                const weekStart = new Date(now);
                weekStart.setDate(now.getDate() - now.getDay());
                weekStart.setHours(0, 0, 0, 0);

                const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);

                const totalTasks = this.state.tasks.length;
                const totalCompleted = this.state.tasks.filter(t => t.completed).length;
                const completionRate = totalTasks > 0 ? (totalCompleted / totalTasks) * 100 : 0;

                const thisWeekCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    return new Date(task.completedAt) >= weekStart;
                }).length;

                const thisMonthCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    return new Date(task.completedAt) >= monthStart;
                }).length;

                const highPriorityCompleted = this.state.tasks.filter(task =>
                    task.completed && (task.priority === 'high' || task.priority === 'critical')
                ).length;

                // Calculer la moyenne par jour (sur les 30 derniers jours)
                const thirtyDaysAgo = new Date(now);
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

                const last30DaysCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    return new Date(task.completedAt) >= thirtyDaysAgo;
                }).length;

                const averagePerDay = last30DaysCompleted / 30;

                // Statistiques par cat√©gorie
                const categoryStats = {};
                this.state.categories.forEach(category => {
                    const categoryTasks = this.state.tasks.filter(t => t.category === category.id);
                    const categoryCompleted = categoryTasks.filter(t => t.completed).length;
                    categoryStats[category.id] = {
                        name: category.name,
                        color: category.color,
                        total: categoryTasks.length,
                        completed: categoryCompleted,
                        rate: categoryTasks.length > 0 ? (categoryCompleted / categoryTasks.length) * 100 : 0
                    };
                });

                return {
                    totalTasks,
                    totalCompleted,
                    completionRate,
                    thisWeekCompleted,
                    thisMonthCompleted,
                    averagePerDay,
                    highPriorityCompleted,
                    categoryStats
                };
            }

            renderCategoryStats(categoryStats) {
                let html = '';
                Object.values(categoryStats).forEach(cat => {
                    if (cat.total > 0) {
                        html += `
                            <div class="stat-item">
                                <span class="stat-label">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: ${cat.color}; border-radius: 50%; margin-right: 8px;"></span>
                                    ${cat.name}
                                </span>
                                <span class="stat-value">${cat.completed}/${cat.total} (${Math.round(cat.rate)}%)</span>
                            </div>
                        `;
                    }
                });
                return html || '<p class="text-muted">Aucune donn√©e disponible</p>';
            }

            renderAchievements(stats) {
                const achievements = [];

                if (stats.totalCompleted >= 10) achievements.push('üèÖ 10 t√¢ches termin√©es');
                if (stats.totalCompleted >= 50) achievements.push('üèÜ 50 t√¢ches termin√©es');
                if (stats.totalCompleted >= 100) achievements.push('üíé 100 t√¢ches termin√©es');
                if (stats.completionRate >= 80) achievements.push('‚≠ê Taux de r√©ussite √©lev√©');
                if (stats.thisWeekCompleted >= 7) achievements.push('üî• Semaine productive');
                if (this.calculateStreak() >= 7) achievements.push('üìÖ S√©rie de 7 jours');
                if (stats.highPriorityCompleted >= 10) achievements.push('üéØ Ma√Ætre des priorit√©s');

                if (achievements.length === 0) {
                    return '<p class="text-muted">Continuez √† terminer des t√¢ches pour d√©bloquer des r√©alisations !</p>';
                }

                return achievements.map(achievement =>
                    `<div class="achievement-item" style="padding: var(--spacing-sm); background: var(--secondary-color)20; border-radius: var(--border-radius); margin-bottom: var(--spacing-xs);">${achievement}</div>`
                ).join('');
            }

            // Syst√®me d'IA simul√©e et gamification

            renderAISuggestions() {
                const suggestionsContainer = document.getElementById('ai-suggestions');
                if (!suggestionsContainer) return;

                const suggestions = this.generateAISuggestions();

                if (suggestions.length === 0) {
                    suggestionsContainer.innerHTML = '<p class="text-muted text-xs">Aucune suggestion pour le moment</p>';
                    return;
                }

                let suggestionsHTML = '';
                suggestions.slice(0, 3).forEach(suggestion => {
                    suggestionsHTML += `
                        <div class="suggestion-item" onclick="app.applySuggestion('${suggestion.type}', '${suggestion.data}')">
                            <span class="suggestion-icon">${suggestion.icon}</span>
                            <span class="suggestion-text">${suggestion.text}</span>
                        </div>
                    `;
                });

                suggestionsContainer.innerHTML = suggestionsHTML;
            }

            generateAISuggestions() {
                const suggestions = [];
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

                // Suggestion bas√©e sur les t√¢ches en retard
                const overdueTasks = this.state.tasks.filter(task =>
                    task.dueDate && new Date(task.dueDate) < today && !task.completed
                );

                if (overdueTasks.length > 0) {
                    suggestions.push({
                        type: 'focus_overdue',
                        icon: '‚ö†Ô∏è',
                        text: `Vous avez ${overdueTasks.length} t√¢che${overdueTasks.length > 1 ? 's' : ''} en retard. Concentrez-vous dessus !`,
                        data: 'overdue'
                    });
                }

                // Suggestion bas√©e sur les priorit√©s
                const highPriorityPending = this.state.tasks.filter(task =>
                    !task.completed && (task.priority === 'critical' || task.priority === 'high')
                );

                if (highPriorityPending.length > 0) {
                    suggestions.push({
                        type: 'focus_priority',
                        icon: 'üî•',
                        text: `${highPriorityPending.length} t√¢che${highPriorityPending.length > 1 ? 's' : ''} prioritaire${highPriorityPending.length > 1 ? 's' : ''} en attente`,
                        data: 'high-priority'
                    });
                }

                // Suggestion bas√©e sur les cat√©gories
                const categoryStats = {};
                this.state.tasks.forEach(task => {
                    if (task.category && !task.completed) {
                        categoryStats[task.category] = (categoryStats[task.category] || 0) + 1;
                    }
                });

                const mostUsedCategory = Object.keys(categoryStats).reduce((a, b) =>
                    categoryStats[a] > categoryStats[b] ? a : b, null
                );

                if (mostUsedCategory) {
                    const category = this.state.categories.find(c => c.id === mostUsedCategory);
                    if (category) {
                        suggestions.push({
                            type: 'focus_category',
                            icon: 'üìÇ',
                            text: `Beaucoup de t√¢ches en "${category.name}". Organisez une session d√©di√©e !`,
                            data: mostUsedCategory
                        });
                    }
                }

                // Suggestion de pause si beaucoup de t√¢ches termin√©es aujourd'hui
                const todayCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    const completedDate = new Date(task.completedAt);
                    return completedDate >= today;
                }).length;

                if (todayCompleted >= 5) {
                    suggestions.push({
                        type: 'take_break',
                        icon: '‚òï',
                        text: `Excellent ! ${todayCompleted} t√¢ches termin√©es aujourd'hui. Prenez une pause bien m√©rit√©e !`,
                        data: 'break'
                    });
                }

                // Suggestion de Pomodoro
                const pendingTasks = this.state.tasks.filter(t => !t.completed).length;
                if (pendingTasks > 0 && (!this.state.pomodoro || !this.state.pomodoro.isRunning)) {
                    suggestions.push({
                        type: 'start_pomodoro',
                        icon: 'üçÖ',
                        text: 'D√©marrez un timer Pomodoro pour rester concentr√© !',
                        data: 'pomodoro'
                    });
                }

                return suggestions;
            }

            applySuggestion(type, data) {
                switch (type) {
                    case 'focus_overdue':
                        this.changeFilter('overdue');
                        this.showNotification('Filtrage sur les t√¢ches en retard', 'info');
                        break;
                    case 'focus_priority':
                        this.changeFilter('high-priority');
                        this.showNotification('Filtrage sur les priorit√©s hautes', 'info');
                        break;
                    case 'focus_category':
                        this.filterByCategory(data);
                        this.showNotification('Filtrage par cat√©gorie appliqu√©', 'info');
                        break;
                    case 'take_break':
                        this.showNotification('Vous le m√©ritez ! Prenez une pause üòä', 'success');
                        break;
                    case 'start_pomodoro':
                        this.togglePomodoroTimer();
                        break;
                }
            }

            renderDailyChallenge() {
                const challengeContainer = document.getElementById('daily-challenge');
                if (!challengeContainer) return;

                const challenge = this.getDailyChallenge();
                const progress = this.getChallengeProgress(challenge);

                const challengeHTML = `
                    <div class="challenge-card">
                        <div class="challenge-title">${challenge.icon} ${challenge.title}</div>
                        <div class="challenge-description">${challenge.description}</div>
                        <div class="challenge-progress">
                            <div class="challenge-progress-bar" style="width: ${progress.percentage}%"></div>
                        </div>
                        <div class="challenge-reward">
                            ${progress.current}/${progress.target} ‚Ä¢ R√©compense: ${challenge.reward} points
                        </div>
                    </div>
                `;

                challengeContainer.innerHTML = challengeHTML;

                // V√©rifier si le d√©fi est termin√©
                if (progress.percentage >= 100 && !challenge.completed) {
                    this.completeDailyChallenge(challenge);
                }
            }

            getDailyChallenge() {
                const today = new Date().toDateString();

                // V√©rifier si on a d√©j√† un d√©fi pour aujourd'hui
                if (this.state.dailyChallenge && this.state.dailyChallenge.date === today) {
                    return this.state.dailyChallenge;
                }

                // G√©n√©rer un nouveau d√©fi
                const challenges = [
                    {
                        id: 'complete_3_tasks',
                        title: 'Productivit√©',
                        description: 'Terminez 3 t√¢ches aujourd\'hui',
                        icon: 'üéØ',
                        target: 3,
                        type: 'complete_tasks',
                        reward: 100
                    },
                    {
                        id: 'complete_high_priority',
                        title: 'Priorit√©s',
                        description: 'Terminez 2 t√¢ches de haute priorit√©',
                        icon: 'üî•',
                        target: 2,
                        type: 'complete_high_priority',
                        reward: 150
                    },
                    {
                        id: 'use_pomodoro',
                        title: 'Focus',
                        description: 'Utilisez le timer Pomodoro 2 fois',
                        icon: 'üçÖ',
                        target: 2,
                        type: 'use_pomodoro',
                        reward: 80
                    },
                    {
                        id: 'organize_tasks',
                        title: 'Organisation',
                        description: 'Ajoutez 5 nouvelles t√¢ches avec cat√©gories',
                        icon: 'üìã',
                        target: 5,
                        type: 'add_categorized_tasks',
                        reward: 120
                    }
                ];

                const randomChallenge = challenges[Math.floor(Math.random() * challenges.length)];
                randomChallenge.date = today;
                randomChallenge.completed = false;

                this.state.dailyChallenge = randomChallenge;
                this.saveState();

                return randomChallenge;
            }

            getChallengeProgress(challenge) {
                const today = new Date();
                const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());

                let current = 0;

                switch (challenge.type) {
                    case 'complete_tasks':
                        current = this.state.tasks.filter(task => {
                            if (!task.completed || !task.completedAt) return false;
                            return new Date(task.completedAt) >= todayStart;
                        }).length;
                        break;
                    case 'complete_high_priority':
                        current = this.state.tasks.filter(task => {
                            if (!task.completed || !task.completedAt) return false;
                            if (task.priority !== 'high' && task.priority !== 'critical') return false;
                            return new Date(task.completedAt) >= todayStart;
                        }).length;
                        break;
                    case 'use_pomodoro':
                        current = this.state.pomodoroSessionsToday || 0;
                        break;
                    case 'add_categorized_tasks':
                        current = this.state.tasks.filter(task => {
                            if (!task.category) return false;
                            return new Date(task.createdAt) >= todayStart;
                        }).length;
                        break;
                }

                const percentage = Math.min((current / challenge.target) * 100, 100);

                return {
                    current: Math.min(current, challenge.target),
                    target: challenge.target,
                    percentage
                };
            }

            completeDailyChallenge(challenge) {
                challenge.completed = true;
                this.addPoints(challenge.reward);
                this.showNotification(`D√©fi termin√© ! +${challenge.reward} points üéâ`, 'success');
                this.saveState();
            }

            // Documentation et aide
            showHelp() {
                const helpHTML = `
                    <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto; margin: 20px auto; background: var(--bg-primary); padding: var(--spacing-xl); border-radius: var(--border-radius-lg); box-shadow: var(--shadow-lg);">
                        <h2 style="margin-bottom: var(--spacing-lg); text-align: center;">üìö Guide d'utilisation - TodoList Pro</h2>

                        <div class="help-section">
                            <h3>üöÄ D√©marrage rapide</h3>
                            <ul style="margin: var(--spacing-md) 0; padding-left: var(--spacing-lg);">
                                <li>Tapez <kbd>N</kbd> pour ajouter une nouvelle t√¢che rapidement</li>
                                <li>Utilisez <kbd>F</kbd> pour rechercher dans vos t√¢ches</li>
                                <li>Cliquez sur les ic√¥nes de priorit√© pour organiser vos t√¢ches</li>
                                <li>Glissez-d√©posez les t√¢ches pour les r√©organiser</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚å®Ô∏è Raccourcis clavier</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-md); margin: var(--spacing-md) 0;">
                                <div>
                                    <strong>Navigation :</strong><br>
                                    <kbd>N</kbd> - Nouvelle t√¢che<br>
                                    <kbd>F</kbd> - Rechercher<br>
                                    <kbd>Escape</kbd> - Effacer recherche<br>
                                    <kbd>?</kbd> - Afficher l'aide
                                </div>
                                <div>
                                    <strong>Productivit√© :</strong><br>
                                    <kbd>T</kbd> - Timer Pomodoro<br>
                                    <kbd>Z</kbd> - Mode Focus<br>
                                    <kbd>D</kbd> - Changer de th√®me<br>
                                    <kbd>S</kbd> - Sauvegarder
                                </div>
                            </div>
                        </div>

                        <div style="margin-top: var(--spacing-xl); text-align: center; padding-top: var(--spacing-lg); border-top: 1px solid var(--bg-tertiary);">
                            <p style="color: var(--text-muted); font-size: 0.875rem; margin-bottom: var(--spacing-md);">
                                TodoList Pro - Application de productivit√© avanc√©e<br>
                                Version 1.0 - D√©velopp√©e avec ‚ù§Ô∏è pour votre productivit√©
                            </p>
                            <button class="btn btn-primary" onclick="app.closeSettings()">
                                Fermer l'aide
                            </button>
                        </div>
                    </div>
                `;

                const overlay = document.getElementById('modal-overlay');
                overlay.innerHTML = helpHTML;
                overlay.classList.remove('hidden');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 1000;
                    display: flex;
                    align-items: flex-start;
                    justify-content: center;
                    overflow-y: auto;
                `;
            }

            // Tests et validation
            runSelfTests() {
                console.log('üß™ Ex√©cution des tests automatiques...');

                const tests = [
                    () => this.testTaskCreation(),
                    () => this.testTaskCompletion(),
                    () => this.testCategoryManagement(),
                    () => this.testSearchFunctionality(),
                    () => this.testDataPersistence(),
                    () => this.testAccessibility(),
                    () => this.testPerformance()
                ];

                let passed = 0;
                let failed = 0;

                tests.forEach((test, index) => {
                    try {
                        test();
                        console.log(`‚úÖ Test ${index + 1} r√©ussi`);
                        passed++;
                    } catch (error) {
                        console.error(`‚ùå Test ${index + 1} √©chou√©:`, error);
                        failed++;
                    }
                });

                console.log(`üìä R√©sultats des tests: ${passed} r√©ussis, ${failed} √©chou√©s`);
                return { passed, failed };
            }

            testTaskCreation() {
                const initialCount = this.state.tasks.length;
                const testTask = {
                    id: 'test-' + Date.now(),
                    title: 'Test Task',
                    completed: false,
                    createdAt: new Date().toISOString(),
                    priority: 'normal'
                };

                this.state.tasks.push(testTask);

                if (this.state.tasks.length !== initialCount + 1) {
                    throw new Error('Task creation failed');
                }

                // Nettoyer
                this.state.tasks = this.state.tasks.filter(t => t.id !== testTask.id);
            }

            testTaskCompletion() {
                const testTask = {
                    id: 'test-completion-' + Date.now(),
                    title: 'Test Completion',
                    completed: false,
                    createdAt: new Date().toISOString(),
                    priority: 'normal'
                };

                this.state.tasks.push(testTask);

                // Simuler la completion
                testTask.completed = true;
                testTask.completedAt = new Date().toISOString();

                if (!testTask.completed || !testTask.completedAt) {
                    throw new Error('Task completion failed');
                }

                // Nettoyer
                this.state.tasks = this.state.tasks.filter(t => t.id !== testTask.id);
            }

            testCategoryManagement() {
                const initialCount = this.state.categories.length;
                const testCategory = {
                    id: 'test-cat-' + Date.now(),
                    name: 'Test Category',
                    color: '#ff0000',
                    createdAt: new Date().toISOString()
                };

                this.state.categories.push(testCategory);

                if (this.state.categories.length !== initialCount + 1) {
                    throw new Error('Category creation failed');
                }

                // Nettoyer
                this.state.categories = this.state.categories.filter(c => c.id !== testCategory.id);
            }

            testSearchFunctionality() {
                const testTasks = [
                    { id: '1', title: 'Test Search Task', completed: false },
                    { id: '2', title: 'Another Task', completed: false }
                ];

                const originalTasks = this.state.tasks;
                this.state.tasks = testTasks;

                const results = this.searchTasks('Search');

                if (results.length !== 1 || results[0].title !== 'Test Search Task') {
                    throw new Error('Search functionality failed');
                }

                // Restaurer
                this.state.tasks = originalTasks;
            }

            testDataPersistence() {
                const testData = { test: 'persistence' };
                localStorage.setItem('todoapp-test', JSON.stringify(testData));

                const retrieved = JSON.parse(localStorage.getItem('todoapp-test'));

                if (!retrieved || retrieved.test !== 'persistence') {
                    throw new Error('Data persistence failed');
                }

                // Nettoyer
                localStorage.removeItem('todoapp-test');
            }

            testAccessibility() {
                const liveRegion = document.getElementById('aria-live-region');
                if (!liveRegion) {
                    throw new Error('Accessibility live region not found');
                }

                if (!liveRegion.getAttribute('aria-live')) {
                    throw new Error('Accessibility attributes missing');
                }
            }

            testPerformance() {
                const start = performance.now();

                // Simuler une op√©ration co√ªteuse
                for (let i = 0; i < 1000; i++) {
                    this.calculateStats();
                }

                const end = performance.now();
                const duration = end - start;

                if (duration > 1000) { // Plus d'une seconde
                    throw new Error(`Performance test failed: ${duration}ms`);
                }
            }
        }

        // Initialisation de l'application
        const app = new TodoApp();

        // Fallback pour s'assurer que l'app est visible
        setTimeout(() => {
            const appElement = document.getElementById('app');
            const loadingScreen = document.getElementById('loading-screen');

            if (appElement && appElement.style.opacity !== '1') {
                console.log('üîß Fallback: Affichage forc√© de l\'application');
                appElement.style.opacity = '1';
                appElement.style.transition = 'opacity 0.3s ease-out';
            }

            if (loadingScreen) {
                loadingScreen.remove();
            }
        }, 1200); // Fallback apr√®s 1.2 secondes

        // Ex√©cuter les tests en mode d√©veloppement
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('üöÄ TodoList Pro - Mode d√©veloppement d√©tect√©');
            setTimeout(() => {
                const testResults = app.runSelfTests();
                if (testResults.failed === 0) {
                    console.log('‚úÖ Tous les tests sont pass√©s avec succ√®s !');
                } else {
                    console.warn(`‚ö†Ô∏è ${testResults.failed} test(s) ont √©chou√©`);
                }
            }, 2500);
        }
    </script>
</body>

</html>