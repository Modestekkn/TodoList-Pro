<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoList Pro</title>
    <link rel="shortcut icon" href="./task-icon.png" type="image/x-icon">
    <!-- Google Fonts - Roboto -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600;700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
        rel="stylesheet">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link rel="stylesheet" href="style.css">
</head>

<body>
    <!-- Écran de chargement -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-content">
            <div class="loading-logo"><img
                    src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTiViquTVNf5gqaLzyGE_NwLWcfKsUf3I4xIQ&s"
                    alt="Logo de l'app" srcset=""></div>
            <h2 class="loading-title">TodoList Pro</h2>
            <div class="loading-spinner"></div>
            <p class="loading-text">Chargement de votre espace de productivité...</p>
        </div>
    </div>

    <!-- Overlay pour fermer la sidebar sur mobile -->
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <div class="app-container" id="app" style="opacity: 0; transition: opacity 0.8s ease-out;">
        <!-- Header -->
        <header class="app-header" role="banner">
            <div class="header-left">
                <button class="btn btn-secondary btn-icon hamburger-btn" id="sidebar-toggle"
                    aria-label="Ouvrir/fermer la barre latérale" aria-expanded="true" aria-controls="sidebar">
                    <i class="fas fa-bars" aria-hidden="true"></i>
                </button>
                <div class="app-logo-container">
                    <div class="app-logo"><i class="fas fa-clipboard-list"></i></div>
                    <h1 class="app-title">TodoList Pro</h1>
                </div>
            </div>

            <div class="header-center">
                <!-- Barre de recherche -->
                <div class="search-container" role="search">
                    <label for="search-input" class="sr-only">Rechercher dans les tâches</label>
                    <input type="text" class="input search-input" id="search-input" placeholder="Rechercher..."
                        aria-label="Rechercher dans les tâches" autocomplete="off">
                    <button class="btn btn-secondary btn-icon" id="clear-search" title="Effacer la recherche"
                        aria-label="Effacer la recherche">
                        <i class="fas fa-times" aria-hidden="true"></i>
                    </button>
                </div>
                <!-- Timer Pomodoro -->
                <div class="pomodoro-timer" id="pomodoro-timer">
                    <span class="timer-display" id="timer-display">25:00</span>
                    <button class="btn btn-secondary btn-icon" id="timer-toggle" title="Démarrer/Arrêter le timer"><i
                            class="fas fa-play"></i></button>
                </div>
                <div class="stats-summary" id="stats-summary">
                    <span class="text-sm text-center">0 tâches</span>
                </div>
            </div>

            <div class="header-right">
                <button class="btn btn-secondary btn-icon" id="focus-mode-toggle" title="Mode Focus"><i
                        class="fas fa-bullseye"></i></button>
                <button class="btn btn-secondary btn-icon" id="theme-toggle">
                    <i class="fas fa-moon"></i>
                </button>
                <button class="btn btn-secondary btn-icon" id="help-btn" title="Aide et documentation"><i
                        class="fas fa-question-circle"></i></button>
                <button class="btn btn-secondary btn-icon" id="settings-btn">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="app-sidebar" id="sidebar">
            <div class="sidebar-content">
                <!-- Bouton de fermeture pour mobile -->
                <div class="sidebar-header mobile-only">
                    <h2 class="sidebar-title">Menu</h2>
                    <button class="mobile-close-btn" id="close-sidebar-btn" aria-label="Fermer le menu">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Navigation principale -->
                <nav class="main-nav">
                    <h3 class="font-medium text-sm text-muted mb-2">VUES</h3>
                    <ul class="nav-list">
                        <li><a href="#" class="nav-item active" data-view="list"><i class="fas fa-list"></i> Liste</a>
                        </li>
                        <li><a href="#" class="nav-item" data-view="kanban"><i class="fas fa-columns"></i> Kanban</a>
                        </li>
                        <li><a href="#" class="nav-item" data-view="calendar"><i class="fas fa-calendar-alt"></i>
                                Calendrier</a></li>
                        <li><a href="#" class="nav-item" data-view="timeline"><i class="fas fa-clock"></i> Timeline</a>
                        </li>
                    </ul>
                </nav>

                <!-- Filtres rapides -->
                <div class="quick-filters">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4">FILTRES</h3>
                    <ul class="filter-list">
                        <li><a href="#" class="filter-item" data-filter="all"><i class="fas fa-tasks"></i> Toutes les
                                tâches</a></li>
                        <li><a href="#" class="filter-item" data-filter="today"><i class="fas fa-calendar-day"></i>
                                Aujourd'hui</a></li>
                        <li><a href="#" class="filter-item" data-filter="upcoming"><i class="fas fa-clock"></i> À
                                venir</a></li>
                        <li><a href="#" class="filter-item" data-filter="overdue"><i
                                    class="fas fa-exclamation-triangle"></i> En retard</a></li>
                        <li><a href="#" class="filter-item" data-filter="completed"><i class="fas fa-check-circle"></i>
                                Terminées</a></li>
                        <li><a href="#" class="filter-item" data-filter="favorites"><i class="fas fa-star"></i>
                                Favoris</a></li>
                        <li><a href="#" class="filter-item" data-filter="high-priority"><i class="fas fa-fire"></i>
                                Priorité haute</a></li>
                    </ul>
                </div>

                <!-- Statistiques -->
                <div class="stats-widget">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4">STATISTIQUES</h3>
                    <div class="stats-summary-widget" id="stats-widget">
                        <!-- Les statistiques seront générées dynamiquement -->
                    </div>
                    <button class="btn btn-secondary text-xs mt-2" id="show-detailed-stats">
                        <i class="fas fa-chart-bar"></i> Voir les détails
                    </button>
                </div>

                <!-- IA et Gamification -->
                <div class="ai-suggestions">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4"><i class="fas fa-robot"></i> SUGGESTIONS IA</h3>
                    <div class="suggestions-container" id="ai-suggestions">
                        <!-- Les suggestions seront générées dynamiquement -->
                    </div>
                </div>

                <div class="daily-challenge">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4"><i class="fas fa-bullseye"></i> DÉFI DU JOUR</h3>
                    <div class="challenge-container" id="daily-challenge">
                        <!-- Le défi sera généré dynamiquement -->
                    </div>
                </div>

                <!-- Mini calendrier -->
                <div class="mini-calendar">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4">CALENDRIER</h3>
                    <div class="calendar-widget" id="mini-calendar">
                        <!-- Le calendrier sera généré dynamiquement -->
                    </div>
                </div>

                <!-- Catégories -->
                <div class="categories">
                    <h3 class="font-medium text-sm text-muted mb-2 mt-4">CATÉGORIES</h3>
                    <div class="category-list" id="category-list">
                        <!-- Les catégories seront ajoutées dynamiquement -->
                    </div>
                    <button class="btn btn-secondary text-xs mt-2" id="add-category-btn">
                        + Nouvelle catégorie
                    </button>
                </div>
            </div>
        </aside>

        <!-- Contenu principal -->
        <main class="app-main">
            <div class="main-content" id="main-content">
                <!-- Zone d'ajout de tâche -->
                <div class="task-input-section">
                    <div class="task-input-container">
                        <div class="input-with-icon">
                            <i class="fas fa-plus-circle input-icon"></i>
                            <input type="text" class="input" id="task-input" placeholder="Ajouter une nouvelle tâche..."
                                autocomplete="off">
                        </div>
                        <div class="task-options">
                            <!-- Ligne 1 : Titre + Priorité | Catégorie + Date d'échéance -->
                            <div class="form-row main-form">
                                <div class="form-field">
                                    <label for="task-priority" class="form-label">
                                        <i class="fas fa-flag"></i> Priorité
                                    </label>
                                    <select class="input" id="task-priority">
                                        <option value="normal">🔵 Normal</option>
                                        <option value="low">🟢 Basse</option>
                                        <option value="high">🟠 Haute</option>
                                        <option value="critical">🔴 Critique</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <label for="task-category" class="form-label">
                                        <i class="fas fa-folder"></i> Catégorie
                                    </label>
                                    <select class="input" id="task-category">
                                        <option value="">Aucune catégorie</option>
                                    </select>
                                </div>
                                <div class="form-field">
                                    <label for="task-due-date" class="form-label">
                                        <i class="fas fa-calendar-alt"></i> Date d'échéance
                                    </label>
                                    <input type="date" class="input" id="task-due-date">
                                </div>
                            </div>
                            <!-- Ligne 2 : Horaires (prend toute la largeur) -->
                            <div class="form-row time-row">
                                <div class="form-field time-field">
                                    <label class="form-label">
                                        <i class="fas fa-clock"></i> Horaires
                                    </label>
                                    <div class="time-group">
                                        <input type="time" class="input" id="task-start-time" title="Heure de début">
                                        <span class="time-separator">à</span>
                                        <input type="time" class="input" id="task-end-time" title="Heure de fin">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="buttons-row">
                            <button class="btn btn-primary" id="add-task-btn">
                                <i class="fas fa-plus"></i> Ajouter la tâche
                            </button>
                            <button class="btn btn-secondary text-xs toggle-btn" id="toggle-advanced">
                                <i class="fas fa-cog"></i>
                                <span>Options avancées</span>
                                <i class="fas fa-chevron-down toggle-icon"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Options avancées (masquées par défaut) -->
                    <div class="advanced-options hidden" id="advanced-options">
                        <h4 class="advanced-options-title">
                            <i class="fas fa-cog"></i> Options avancées
                        </h4>
                        <div class="form-row">
                            <div class="form-field">
                                <label for="task-description" class="form-label">
                                    <i class="fas fa-align-left"></i> Description
                                </label>
                                <input type="text" class="input" id="task-description" placeholder="Description de la tâche...">
                            </div>
                            <div class="form-field">
                                <label for="task-tags" class="form-label">
                                    <i class="fas fa-tags"></i> Tags
                                </label>
                                <input type="text" class="input" id="task-tags" placeholder="tag1, tag2, tag3...">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-field">
                                <label for="task-estimated-time" class="form-label">
                                    <i class="fas fa-hourglass-half"></i> Temps estimé (min)
                                </label>
                                <input type="number" class="input" id="task-estimated-time" placeholder="En minutes" min="1">
                            </div>
                            <div class="form-field">
                                <label for="task-recurring" class="form-label">
                                    <i class="fas fa-redo"></i> Récurrence
                                </label>
                                <select class="input" id="task-recurring">
                                    <option value="">Pas de récurrence</option>
                                    <option value="daily">Quotidien</option>
                                    <option value="weekly">Hebdomadaire</option>
                                    <option value="monthly">Mensuel</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Zone principale des tâches -->
                <div class="tasks-container" id="tasks-container">
                    <!-- Les tâches seront affichées ici -->
                </div>
            </div>
        </main>
    </div>

    <!-- Modal overlay pour les paramètres et l'aide -->
    <div id="modal-overlay" class="hidden"></div>

    <!-- Modales et overlays -->
    <div class="modal-overlay hidden" id="modal-overlay"></div>

    <script>
        // Architecture modulaire de l'application
        class TodoApp {
            constructor() {
                this.state = {
                    tasks: [],
                    categories: [],
                    currentView: 'list',
                    currentFilter: 'all',
                    theme: 'light',
                    settings: {},
                    calendarDate: new Date() // Initialiser le calendrier sur aujourd'hui
                };

                this.modules = {};
                this.init();
            }

            init() {
                this.loadState();
                this.initDefaultCategories();
                this.initCalendar();
                this.applyTheme();
                this.initAccessibility();
                this.initPerformanceOptimizations();
                this.initModules();
                this.bindEvents();
                this.initMobileLayout();
                this.render();
                this.checkOverdueTasks();

                // Animation d'entrée de l'application
                this.animateAppEntrance();

                // Vérifier les tâches en retard toutes les heures
                setInterval(() => this.checkOverdueTasks(), 3600000);
            }

            animateAppEntrance() {
                // Vérifier les préférences de mouvement réduit
                const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                const delay = prefersReducedMotion ? 200 : 2500;

                // Afficher l'application rapidement
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loading-screen');
                    const app = document.getElementById('app');

                    // Afficher l'application immédiatement
                    if (app) {
                        app.style.opacity = '1';
                        app.style.transition = prefersReducedMotion ? 'opacity 0.5s ease-out' : 'opacity 0.8s ease-out';
                    }

                    // Masquer l'écran de chargement
                    if (loadingScreen) {
                        loadingScreen.style.opacity = '0';
                        loadingScreen.style.transition = prefersReducedMotion ? 'opacity 0.5s ease-out' : 'opacity 0.8s ease-out';

                        // Supprimer l'écran de chargement après l'animation
                        const removeDelay = prefersReducedMotion ? 200 : 800;
                        setTimeout(() => {
                            loadingScreen.remove();
                        }, removeDelay);
                    }
                }, delay);
            }

            initAccessibility() {
                // Détecter les préférences d'accessibilité
                if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    document.body.classList.add('reduced-motion');
                }

                if (window.matchMedia('(prefers-contrast: high)').matches) {
                    document.body.classList.add('high-contrast');
                }

                // Gérer les annonces pour les lecteurs d'écran
                this.createAriaLiveRegion();

                // Améliorer la navigation au clavier
                this.setupKeyboardNavigation();
            }

            createAriaLiveRegion() {
                const liveRegion = document.createElement('div');
                liveRegion.id = 'aria-live-region';
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.className = 'sr-only';
                document.body.appendChild(liveRegion);
            }

            announceToScreenReader(message) {
                const liveRegion = document.getElementById('aria-live-region');
                if (liveRegion) {
                    liveRegion.textContent = message;
                    setTimeout(() => {
                        liveRegion.textContent = '';
                    }, 1000);
                }
            }

            setupKeyboardNavigation() {
                // Améliorer la navigation dans les listes
                document.addEventListener('keydown', (e) => {
                    if (e.target.classList.contains('nav-item') || e.target.classList.contains('filter-item')) {
                        this.handleListNavigation(e);
                    }
                });
            }

            handleListNavigation(e) {
                const items = Array.from(e.target.parentElement.children);
                const currentIndex = items.indexOf(e.target);
                let nextIndex;

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        nextIndex = (currentIndex + 1) % items.length;
                        items[nextIndex].focus();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        nextIndex = currentIndex === 0 ? items.length - 1 : currentIndex - 1;
                        items[nextIndex].focus();
                        break;
                    case 'Home':
                        e.preventDefault();
                        items[0].focus();
                        break;
                    case 'End':
                        e.preventDefault();
                        items[items.length - 1].focus();
                        break;
                }
            }

            initPerformanceOptimizations() {
                // Debounce pour la recherche
                this.searchDebounce = this.debounce((query) => {
                    this.performSearch(query);
                }, 300);

                // Throttle pour le scroll
                this.scrollThrottle = this.throttle(() => {
                    this.handleScroll();
                }, 100);

                // Observer pour le lazy loading
                this.setupIntersectionObserver();
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            throttle(func, limit) {
                let inThrottle;
                return function () {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            }

            setupIntersectionObserver() {
                if ('IntersectionObserver' in window) {
                    this.intersectionObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                this.loadLazyContent(entry.target);
                            }
                        });
                    }, {
                        rootMargin: '50px'
                    });
                }
            }

            loadLazyContent(element) {
                // Charger le contenu lazy
                if (element.dataset.lazy === 'true') {
                    element.dataset.lazy = 'false';
                    // Logique de chargement du contenu
                    this.intersectionObserver.unobserve(element);
                }
            }

            applyTheme() {
                if (this.state.theme && this.state.theme !== 'light') {
                    this.setTheme(this.state.theme);
                }
            }

            checkOverdueTasks() {
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

                const overdueTasks = this.state.tasks.filter(task => {
                    if (!task.dueDate || task.completed) return false;
                    return new Date(task.dueDate) < today;
                });

                if (overdueTasks.length > 0) {
                    const message = overdueTasks.length === 1 ?
                        '1 tâche en retard !' :
                        `${overdueTasks.length} tâches en retard !`;

                    // Afficher une notification discrète
                    setTimeout(() => {
                        this.showNotification(message, 'warning');
                    }, 2000);
                }
            }

            loadState() {
                // Chargement de l'état depuis localStorage
                const savedState = localStorage.getItem('todoapp-state');
                if (savedState) {
                    this.state = { ...this.state, ...JSON.parse(savedState) };
                }

                // Restaurer l'état du sidebar
                const sidebarCollapsed = localStorage.getItem('sidebar-collapsed') === 'true';
                if (sidebarCollapsed && window.innerWidth > 768) {
                    const sidebar = document.getElementById('sidebar');
                    const container = document.getElementById('app');
                    sidebar.classList.add('hidden');
                    container.classList.add('sidebar-collapsed');
                }
            }

            saveState() {
                // Sauvegarde de l'état dans localStorage
                localStorage.setItem('todoapp-state', JSON.stringify(this.state));
            }

            initModules() {
                // Initialisation des modules (sera étendu)
                console.log('Initialisation des modules...');
            }

            bindEvents() {
                // Liaison des événements de base
                document.getElementById('sidebar-toggle').addEventListener('click', this.toggleSidebar.bind(this));
                document.getElementById('theme-toggle').addEventListener('click', this.toggleTheme.bind(this));
                document.getElementById('add-task-btn').addEventListener('click', this.addTask.bind(this));
                document.getElementById('task-input').addEventListener('keypress', this.handleTaskInputKeypress.bind(this));
                document.getElementById('toggle-advanced').addEventListener('click', this.toggleAdvancedOptions.bind(this));
                document.getElementById('add-category-btn').addEventListener('click', this.addCategory.bind(this));
                document.getElementById('search-input').addEventListener('input', this.handleSearch.bind(this));
                document.getElementById('clear-search').addEventListener('click', this.clearSearch.bind(this));
                document.getElementById('timer-toggle').addEventListener('click', this.togglePomodoroTimer.bind(this));
                document.getElementById('focus-mode-toggle').addEventListener('click', this.toggleFocusMode.bind(this));
                document.getElementById('settings-btn').addEventListener('click', this.showSettings.bind(this));
                document.getElementById('show-detailed-stats').addEventListener('click', this.showDetailedStats.bind(this));
                document.getElementById('help-btn').addEventListener('click', this.showHelp.bind(this));

                // Événements pour les filtres et vues
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.changeView(item.dataset.view);
                    });
                });

                document.querySelectorAll('.filter-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.changeFilter(item.dataset.filter);
                    });
                });

                // Raccourcis clavier
                document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));

                // Gestion mobile de la sidebar
                document.getElementById('sidebar-overlay').addEventListener('click', this.closeSidebar.bind(this));
                document.getElementById('close-sidebar-btn').addEventListener('click', this.closeSidebar.bind(this));

                // Gestion du redimensionnement pour le responsive
                window.addEventListener('resize', this.handleResize.bind(this));
            }

            // Gestion mobile de la sidebar
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const container = document.getElementById('app');
                const isMobile = window.innerWidth <= 768;

                if (isMobile) {
                    sidebar.classList.toggle('open');
                    overlay.classList.toggle('active');
                } else {
                    sidebar.classList.toggle('hidden');
                    // Ajouter classe au container pour faciliter le CSS
                    container.classList.toggle('sidebar-collapsed');
                    
                    // Sauvegarder l'état du sidebar
                    const isCollapsed = sidebar.classList.contains('hidden');
                    localStorage.setItem('sidebar-collapsed', isCollapsed.toString());
                }
            }

            closeSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');

                sidebar.classList.remove('open');
                overlay.classList.remove('active');
            }

            handleResize() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');
                const isMobile = window.innerWidth <= 768;

                if (!isMobile) {
                    sidebar.classList.remove('open');
                    overlay.classList.remove('active');
                }
            }

            initMobileLayout() {
                // S'assurer que la sidebar soit fermée par défaut sur mobile
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    this.closeSidebar();
                }
            }

            handleKeyboardShortcuts(e) {
                // Ignorer si on est dans un champ de saisie
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    // Permettre Escape pour sortir des champs
                    if (e.key === 'Escape') {
                        e.target.blur();
                    }
                    return;
                }

                // Raccourcis globaux
                switch (e.key) {
                    case 'n':
                    case 'N':
                        // Nouvelle tâche
                        e.preventDefault();
                        document.getElementById('task-input').focus();
                        break;
                    case 'f':
                    case 'F':
                        // Focus sur la recherche
                        e.preventDefault();
                        document.getElementById('search-input').focus();
                        break;
                    case 's':
                    case 'S':
                        // Sauvegarder (déjà automatique, mais feedback)
                        e.preventDefault();
                        this.showNotification('Sauvegarde automatique active', 'info');
                        break;
                    case 't':
                    case 'T':
                        // Toggle timer Pomodoro
                        e.preventDefault();
                        this.togglePomodoroTimer();
                        break;
                    case 'z':
                    case 'Z':
                        // Mode Focus
                        e.preventDefault();
                        this.toggleFocusMode();
                        break;
                    case 'd':
                    case 'D':
                        // Thème sombre
                        e.preventDefault();
                        this.toggleTheme();
                        break;
                    case '1':
                        e.preventDefault();
                        this.changeFilter('all');
                        break;
                    case '2':
                        e.preventDefault();
                        this.changeFilter('today');
                        break;
                    case '3':
                        e.preventDefault();
                        this.changeFilter('upcoming');
                        break;
                    case '4':
                        e.preventDefault();
                        this.changeFilter('overdue');
                        break;
                    case '5':
                        e.preventDefault();
                        this.changeFilter('completed');
                        break;
                    case 'Escape':
                        // Effacer la recherche ou sortir du mode focus
                        if (this.state.searchQuery) {
                            this.clearSearch();
                        } else if (document.body.classList.contains('focus-mode')) {
                            this.toggleFocusMode();
                        }
                        break;
                    case '?':
                        // Afficher l'aide des raccourcis
                        e.preventDefault();
                        this.showKeyboardHelp();
                        break;
                }
            }

            showKeyboardHelp() {
                const helpText = `
Raccourcis clavier disponibles:

N - Nouvelle tâche
F - Rechercher
T - Timer Pomodoro
Z - Mode Focus
D - Thème sombre
S - Sauvegarder

1 - Toutes les tâches
2 - Aujourd'hui
3 - À venir
4 - En retard
5 - Terminées

Escape - Effacer recherche/Sortir du mode focus
? - Afficher cette aide
                `;

                this.alert(helpText, 'Aide - Raccourcis clavier');
            }

            // Méthodes pour les popups personnalisées
            async prompt(message, defaultValue = '', title = 'Saisie') {
                return new Promise((resolve) => {
                    const overlay = document.getElementById('modal-overlay');
                    const promptHTML = `
                        <div class="popup-content" style="max-width: 400px;">
                            <div class="popup-header">
                                <h3>${title}</h3>
                                <button class="btn-close" onclick="this.closest('.popup-content').parentElement.classList.add('hidden'); document.querySelector('.popup-input').resolve(null);">×</button>
                            </div>
                            <div class="popup-body">
                                <p>${message}</p>
                                <input type="text" class="input popup-input" value="${defaultValue}" placeholder="Entrez votre réponse..." style="width: 100%; margin-top: 10px;">
                            </div>
                            <div class="popup-footer">
                                <button class="btn btn-secondary popup-cancel">Annuler</button>
                                <button class="btn btn-primary popup-confirm">Confirmer</button>
                            </div>
                        </div>
                    `;

                    overlay.innerHTML = promptHTML;
                    overlay.classList.remove('hidden');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;

                    const input = overlay.querySelector('.popup-input');
                    const confirmBtn = overlay.querySelector('.popup-confirm');
                    const cancelBtn = overlay.querySelector('.popup-cancel');
                    const closeBtn = overlay.querySelector('.btn-close');

                    input.focus();
                    input.select();

                    const closeModal = (result) => {
                        overlay.classList.add('hidden');
                        resolve(result);
                    };

                    confirmBtn.addEventListener('click', () => {
                        closeModal(input.value.trim() || null);
                    });

                    cancelBtn.addEventListener('click', () => {
                        closeModal(null);
                    });

                    closeBtn.addEventListener('click', () => {
                        closeModal(null);
                    });

                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            closeModal(input.value.trim() || null);
                        } else if (e.key === 'Escape') {
                            closeModal(null);
                        }
                    });

                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            closeModal(null);
                        }
                    });
                });
            }

            async alert(message, title = 'Information') {
                return new Promise((resolve) => {
                    const overlay = document.getElementById('modal-overlay');
                    const alertHTML = `
                        <div class="popup-content" style="max-width: 400px;">
                            <div class="popup-header">
                                <h3>${title}</h3>
                                <button class="btn-close" onclick="this.closest('.popup-content').parentElement.classList.add('hidden');">×</button>
                            </div>
                            <div class="popup-body">
                                <p style="white-space: pre-line;">${message}</p>
                            </div>
                            <div class="popup-footer">
                                <button class="btn btn-primary popup-ok">OK</button>
                            </div>
                        </div>
                    `;

                    overlay.innerHTML = alertHTML;
                    overlay.classList.remove('hidden');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;

                    const okBtn = overlay.querySelector('.popup-ok');
                    const closeBtn = overlay.querySelector('.btn-close');

                    const closeModal = () => {
                        overlay.classList.add('hidden');
                        resolve();
                    };

                    okBtn.addEventListener('click', closeModal);
                    closeBtn.addEventListener('click', closeModal);

                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            closeModal();
                        }
                    });

                    document.addEventListener('keydown', function escapeHandler(e) {
                        if (e.key === 'Escape') {
                            document.removeEventListener('keydown', escapeHandler);
                            closeModal();
                        }
                    });
                });
            }

            async confirm(message, title = 'Confirmation') {
                return new Promise((resolve) => {
                    const overlay = document.getElementById('modal-overlay');
                    const confirmHTML = `
                        <div class="popup-content" style="max-width: 400px;">
                            <div class="popup-header">
                                <h3>${title}</h3>
                                <button class="btn-close" onclick="this.closest('.popup-content').parentElement.classList.add('hidden');">×</button>
                            </div>
                            <div class="popup-body">
                                <p style="white-space: pre-line;">${message}</p>
                            </div>
                            <div class="popup-footer">
                                <button class="btn btn-secondary popup-cancel">Annuler</button>
                                <button class="btn btn-danger popup-confirm">Confirmer</button>
                            </div>
                        </div>
                    `;

                    overlay.innerHTML = confirmHTML;
                    overlay.classList.remove('hidden');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;

                    const confirmBtn = overlay.querySelector('.popup-confirm');
                    const cancelBtn = overlay.querySelector('.popup-cancel');
                    const closeBtn = overlay.querySelector('.btn-close');

                    const closeModal = (result) => {
                        overlay.classList.add('hidden');
                        resolve(result);
                    };

                    confirmBtn.addEventListener('click', () => {
                        closeModal(true);
                    });

                    cancelBtn.addEventListener('click', () => {
                        closeModal(false);
                    });

                    closeBtn.addEventListener('click', () => {
                        closeModal(false);
                    });

                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            closeModal(false);
                        }
                    });

                    document.addEventListener('keydown', function escapeHandler(e) {
                        if (e.key === 'Escape') {
                            document.removeEventListener('keydown', escapeHandler);
                            closeModal(false);
                        }
                    });
                });
            }

            // Vues avancées

            // Vue Kanban
            renderKanbanView() {
                const container = document.getElementById('tasks-container');

                const columns = [
                    { id: 'todo', title: '<i class="fas fa-tasks"></i> À faire', filter: (task) => !task.completed && !task.dependencies?.some(depId => !this.state.tasks.find(t => t.id === depId)?.completed) },
                    { id: 'in-progress', title: '<i class="fas fa-spinner"></i> En cours', filter: (task) => !task.completed && task.actualTime > 0 },
                    { id: 'blocked', title: '<i class="fas fa-ban"></i> Bloquées', filter: (task) => !task.completed && !this.canCompleteTask(task) },
                    { id: 'done', title: '<i class="fas fa-check-circle"></i> Terminées', filter: (task) => task.completed }
                ];

                let kanbanHTML = '<div class="kanban-board">';

                columns.forEach(column => {
                    const tasks = this.state.tasks.filter(column.filter);

                    kanbanHTML += `
                        <div class="kanban-column" data-column="${column.id}">
                            <div class="kanban-header">
                                <div class="kanban-title">
                                    ${column.title}
                                    <span class="kanban-count">${tasks.length}</span>
                                </div>
                            </div>
                            <div class="kanban-tasks" ondrop="app.handleKanbanDrop(event, '${column.id}')" ondragover="app.handleKanbanDragOver(event)">
                    `;

                    tasks.forEach(task => {
                        kanbanHTML += this.createKanbanTaskElement(task);
                    });

                    kanbanHTML += '</div></div>';
                });

                kanbanHTML += '</div>';
                container.innerHTML = kanbanHTML;
            }

            createKanbanTaskElement(task) {
                const categoryInfo = this.getCategoryInfo(task.category);
                const dueDateInfo = this.getDueDateInfo(task.dueDate);

                return `
                    <div class="kanban-task priority-${task.priority}" draggable="true"
                         ondragstart="app.handleKanbanDragStart(event, '${task.id}')"
                         data-task-id="${task.id}">
                        <div class="task-header">
                            <span class="task-title">${task.title}</span>
                            ${categoryInfo}
                        </div>
                        ${task.description ? `<div class="task-description">${task.description}</div>` : ''}
                        ${dueDateInfo}
                        ${task.timeRange ? `<div class="task-time-range"><i class="fas fa-clock"></i> ${task.timeRange}</div>` : ''}
                        ${task.subtasks.length > 0 ? `<div class="task-subtasks-count">${task.subtasks.filter(st => st.completed).length}/${task.subtasks.length} sous-tâches</div>` : ''}
                        <div class="task-actions" style="opacity: 1; margin-top: 8px;">
                            <button class="btn-icon" onclick="app.editTask('${task.id}')" title="Modifier"><i class="fas fa-edit"></i></button>
                            <button class="btn-icon" onclick="app.toggleTask('${task.id}')" title="${task.completed ? 'Marquer comme non terminée' : 'Marquer comme terminée'}">
                                <i class="fas ${task.completed ? 'fa-undo' : 'fa-check'}"></i>
                            </button>
                        </div>
                    </div>
                `;
            }

            handleKanbanDragStart(e, taskId) {
                e.dataTransfer.setData('text/plain', taskId);
                e.target.classList.add('dragging');
            }

            handleKanbanDragOver(e) {
                e.preventDefault();
                e.currentTarget.closest('.kanban-column').classList.add('drag-over');
            }

            handleKanbanDrop(e, columnId) {
                e.preventDefault();
                const taskId = e.dataTransfer.getData('text/plain');
                const task = this.state.tasks.find(t => t.id === taskId);

                if (task) {
                    // Logique de changement d'état selon la colonne
                    switch (columnId) {
                        case 'todo':
                            task.completed = false;
                            task.actualTime = 0;
                            break;
                        case 'in-progress':
                            task.completed = false;
                            if (task.actualTime === 0) {
                                task.actualTime = 1; // Marquer comme commencée
                            }
                            break;
                        case 'done':
                            if (this.canCompleteTask(task)) {
                                task.completed = true;
                                task.completedAt = new Date().toISOString();
                            } else {
                                this.showNotification('Impossible de terminer: dépendances non satisfaites', 'warning');
                                return;
                            }
                            break;
                    }

                    task.updatedAt = new Date().toISOString();
                    this.saveState();
                    this.render();
                    this.showNotification('Tâche déplacée !', 'success');
                }

                // Nettoyer les classes
                document.querySelectorAll('.kanban-column').forEach(col => {
                    col.classList.remove('drag-over');
                });
                document.querySelectorAll('.kanban-task').forEach(task => {
                    task.classList.remove('dragging');
                });
            }

            // Vue Timeline
            renderTimelineView() {
                const container = document.getElementById('tasks-container');

                // Filtrer et trier les tâches avec dates d'échéance
                const tasksWithDates = this.state.tasks
                    .filter(task => task.dueDate)
                    .sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));

                if (tasksWithDates.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <p class="text-muted">Aucune tâche avec date d'échéance</p>
                            <p class="text-xs text-muted">Ajoutez des dates d'échéance à vos tâches pour les voir dans la timeline</p>
                        </div>
                    `;
                    return;
                }

                let timelineHTML = `
                    <div class="timeline-view">
                        <div class="timeline-container">
                            <div class="timeline-line"></div>
                `;

                tasksWithDates.forEach((task, index) => {
                    const isLeft = index % 2 === 0;
                    const dueDate = new Date(task.dueDate);
                    const isOverdue = dueDate < new Date() && !task.completed;
                    const categoryInfo = this.getCategoryInfo(task.category);

                    timelineHTML += `
                        <div class="timeline-item ${isLeft ? 'left' : 'right'}">
                            <div class="timeline-content ${isOverdue ? 'overdue' : ''} ${task.completed ? 'completed' : ''}">
                                <div class="task-header">
                                    <span class="task-priority priority-${task.priority}">${this.getPriorityIcon(task.priority)}</span>
                                    <span class="task-title ${task.completed ? 'completed' : ''}">${task.title}</span>
                                    ${categoryInfo}
                                </div>
                                ${task.description ? `<div class="task-description">${task.description}</div>` : ''}
                                ${task.subtasks.length > 0 ? `<div class="task-subtasks-count">${task.subtasks.filter(st => st.completed).length}/${task.subtasks.length} sous-tâches</div>` : ''}
                                <div class="task-actions" style="margin-top: 8px;">
                                    <button class="btn-icon" onclick="app.editTask('${task.id}')" title="Modifier"><i class="fas fa-edit"></i></button>
                                    <button class="btn-icon" onclick="app.toggleTask('${task.id}')" title="${task.completed ? 'Marquer comme non terminée' : 'Marquer comme terminée'}">
                                        <i class="fas ${task.completed ? 'fa-undo' : 'fa-check'}"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="timeline-date">
                                ${dueDate.toLocaleDateString('fr-FR')}
                            </div>
                            <div class="timeline-dot ${task.completed ? 'completed' : ''} ${isOverdue ? 'overdue' : ''}"></div>
                        </div>
                    `;
                });

                timelineHTML += '</div></div>';
                container.innerHTML = timelineHTML;
            }

            // Vue Calendrier complète
            renderCalendarView() {
                const container = document.getElementById('tasks-container');
                const currentDate = this.state.calendarDate ? new Date(this.state.calendarDate) : new Date();

                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const startDate = new Date(firstDay);
                startDate.setDate(startDate.getDate() - firstDay.getDay());

                const monthNames = [
                    'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
                    'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
                ];

                const dayNames = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];

                let calendarHTML = `
                    <div class="calendar-view">
                        <div class="calendar-full">
                            <div class="calendar-full-header">
                                <button class="btn btn-secondary" onclick="app.changeCalendarMonth(-1)">‹ Précédent</button>
                                <h2>${monthNames[month]} ${year}</h2>
                                <button class="btn btn-secondary" onclick="app.changeCalendarMonth(1)">Suivant ›</button>
                            </div>
                            <div class="calendar-full-grid">
                `;

                // En-têtes des jours
                dayNames.forEach(day => {
                    calendarHTML += `<div class="calendar-day-header" style="padding: 12px; font-weight: 600; background: var(--bg-tertiary);">${day}</div>`;
                });

                // Jours du calendrier
                const today = new Date();
                for (let i = 0; i < 42; i++) {
                    const date = new Date(startDate);
                    date.setDate(startDate.getDate() + i);

                    const isToday = date.toDateString() === today.toDateString();
                    const isCurrentMonth = date.getMonth() === month;
                    const tasksForDay = this.getTasksForDate(date);

                    let dayClass = 'calendar-full-day';
                    if (isToday) dayClass += ' today';
                    if (!isCurrentMonth) dayClass += ' other-month';

                    calendarHTML += `
                        <div class="${dayClass}">
                            <div class="calendar-day-number">${date.getDate()}</div>
                    `;

                    // Afficher les tâches du jour
                    tasksForDay.slice(0, 3).forEach(task => {
                        const isOverdue = new Date(task.dueDate) < today && !task.completed;
                        calendarHTML += `
                            <div class="calendar-task-item ${task.completed ? 'completed' : ''} ${isOverdue ? 'overdue' : ''}"
                                 onclick="app.editTask('${task.id}')"
                                 title="${task.title}${task.description ? ' - ' + task.description : ''}"
                                 style="background-color: ${task.completed ? 'var(--secondary-color)' : (isOverdue ? 'var(--danger-color)' : 'var(--primary-color)')}">
                                ${task.title}
                            </div>
                        `;
                    });

                    if (tasksForDay.length > 3) {
                        calendarHTML += `<div class="calendar-task-item" style="background: var(--text-muted);">+${tasksForDay.length - 3} autres</div>`;
                    }

                    calendarHTML += '</div>';
                }

                calendarHTML += '</div></div></div>';
                container.innerHTML = calendarHTML;
            }

            toggleAdvancedOptions() {
                const advancedOptions = document.getElementById('advanced-options');
                const toggleBtn = document.getElementById('toggle-advanced');

                if (advancedOptions.classList.contains('hidden')) {
                    advancedOptions.classList.remove('hidden');
                    toggleBtn.innerHTML = `
                        <i class="fas fa-cog"></i>
                        <span>Masquer les options</span>
                        <i class="fas fa-chevron-up toggle-icon"></i>
                    `;
                    toggleBtn.classList.add('expanded');
                } else {
                    advancedOptions.classList.add('hidden');
                    toggleBtn.innerHTML = `
                        <i class="fas fa-cog"></i>
                        <span>Options avancées</span>
                        <i class="fas fa-chevron-down toggle-icon"></i>
                    `;
                    toggleBtn.classList.remove('expanded');
                }
            }

            async addCategory() {
                const name = await this.prompt('Nom de la nouvelle catégorie:', '', 'Nouvelle catégorie');
                if (name && name.trim()) {
                    const colors = ['#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'];
                    const color = colors[Math.floor(Math.random() * colors.length)];

                    const category = {
                        id: Date.now().toString(),
                        name: name.trim(),
                        color,
                        createdAt: new Date().toISOString()
                    };

                    this.state.categories.push(category);
                    this.saveState();
                    this.renderCategories();
                    this.showNotification('Catégorie ajoutée !', 'success');
                }
            }

            changeView(view) {
                this.state.currentView = view;

                // Mettre à jour l'interface
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`[data-view="${view}"]`).classList.add('active');

                this.render();
                this.showNotification(`Vue changée: ${view}`, 'info');
            }

            changeFilter(filter) {
                this.state.currentFilter = filter;
                this.render();
                this.showNotification(`Filtre appliqué: ${filter}`, 'info');
            }

            toggleTheme() {
                // Système de thèmes simplifié - seulement 3 thèmes
                const themes = ['light', 'dark', 'minimal'];
                const currentIndex = themes.indexOf(this.state.theme || 'light');
                const nextIndex = (currentIndex + 1) % themes.length;

                this.setTheme(themes[nextIndex]);
            }

            setTheme(theme) {
                // Retirer tous les thèmes existants
                document.body.classList.remove('dark-theme', 'minimal-theme');

                // Appliquer le nouveau thème
                this.state.theme = theme;
                if (theme !== 'light') {
                    document.body.classList.add(`${theme}-theme`);
                }

                // Mettre à jour l'icône du bouton
                const themeIcons = {
                    light: 'fa-sun',
                    dark: 'fa-moon',
                    minimal: 'fa-circle'
                };

                const themeNames = {
                    light: 'Clair',
                    dark: 'Sombre',
                    minimal: 'Minimal'
                };

                const themeIcon = document.querySelector('#theme-toggle i');
                if (themeIcon) {
                    themeIcon.className = `fas ${themeIcons[theme]}`;
                }
                this.saveState();
                this.showNotification(`Thème ${themeNames[theme]} activé`, 'success');
            }

            addTask() {
                const input = document.getElementById('task-input');
                const title = input.value.trim();

                if (title) {
        // Récupérer toutes les valeurs du formulaire
        const priority = document.getElementById('task-priority').value;
        const categoryId = document.getElementById('task-category').value || null;
        const dueDate = document.getElementById('task-due-date').value || null;
        const startTime = document.getElementById('task-start-time').value || null;
        const endTime = document.getElementById('task-end-time').value || null;
        const description = document.getElementById('task-description').value.trim();
        const tagsInput = document.getElementById('task-tags').value.trim();
        const estimatedTime = document.getElementById('task-estimated-time').value || null;
        const recurring = document.getElementById('task-recurring').value || null;                    const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag) : [];

        // Valider les horaires si fournis
        let timeRange = null;
        if (startTime && endTime) {
            const startMinutes = this.timeToMinutes(startTime);
            const endMinutes = this.timeToMinutes(endTime);
            if (endMinutes <= startMinutes) {
                this.showNotification('L\'heure de fin doit être après l\'heure de début', 'error');
                return;
            }
            timeRange = `${startTime} - ${endTime}`;
        } else if (startTime || endTime) {
            timeRange = startTime ? `${startTime} - ?` : `? - ${endTime}`;
        }

        const task = {
            id: Date.now().toString(),
            title,
            completed: false,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            priority,
            category: categoryId,
            dueDate,
            startTime,
            endTime,
            timeRange,
            description,
            tags,
            estimatedTime: estimatedTime ? parseInt(estimatedTime) : null,
            actualTime: 0,
            subtasks: [],
            dependencies: [],
            recurring,
            favorite: false
        };                    this.state.tasks.unshift(task);

                    // Réinitialiser le formulaire
                    this.resetTaskForm();

                    // Animation d'ajout
                    this.animateTaskAdd();

                    this.saveState();
                    this.render();

                    // Notification de succès
                    this.showNotification('Tâche ajoutée avec succès !', 'success');
                }
            }

            timeToMinutes(timeString) {
                const [hours, minutes] = timeString.split(':').map(Number);
                return hours * 60 + minutes;
            }

            resetTaskForm() {
                document.getElementById('task-input').value = '';
                document.getElementById('task-priority').value = 'normal';
                document.getElementById('task-category').value = '';
                document.getElementById('task-due-date').value = '';
                document.getElementById('task-start-time').value = '';
                document.getElementById('task-end-time').value = '';
                document.getElementById('task-description').value = '';
                document.getElementById('task-tags').value = '';
                document.getElementById('task-estimated-time').value = '';
                document.getElementById('task-recurring').value = '';

                // Masquer les options avancées
                document.getElementById('advanced-options').classList.add('hidden');
                const toggleBtn = document.getElementById('toggle-advanced');
                toggleBtn.innerHTML = `
                    <i class="fas fa-cog"></i>
                    <span>Options avancées</span>
                    <i class="fas fa-chevron-down toggle-icon"></i>
                `;
                toggleBtn.classList.remove('expanded');
            }

            animateTaskAdd() {
                const input = document.getElementById('task-input');
                input.style.transform = 'scale(1.05)';
                setTimeout(() => {
                    input.style.transform = 'scale(1)';
                }, 150);
            }

            showNotification(message, type = 'info') {
                // Système de notification plus discret avec toast
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.innerHTML = `
                    <span class="toast-icon">
                        ${type === 'success' ? '✓' : type === 'error' ? '✗' : type === 'warning' ? '⚠' : 'ℹ'}
                    </span>
                    <span class="toast-message">${message}</span>
                `;

                // Styles inline pour éviter la dépendance CSS
                toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: var(--bg-primary);
                    color: var(--text-primary);
                    padding: 10px 16px;
                    border-radius: 6px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 1000;
                    font-size: 14px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    border-left: 3px solid ${type === 'success' ? 'var(--priority-low)' : 
                                           type === 'error' ? 'var(--priority-critical)' : 
                                           type === 'warning' ? 'var(--priority-high)' : 'var(--primary-color)'};
                    transform: translateX(100%);
                    transition: transform 0.3s ease-out;
                    max-width: 320px;
                `;

                document.body.appendChild(toast);

                // Animation d'entrée
                requestAnimationFrame(() => {
                    toast.style.transform = 'translateX(0)';
                });

                // Annoncer aux lecteurs d'écran
                this.announceToScreenReader(message);

                // Supprimer après 2.5 secondes (réduit de 3s)
                setTimeout(() => {
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }, 2500);
            }

            handleTaskInputKeypress(e) {
                if (e.key === 'Enter') {
                    this.addTask();
                }
            }

            render() {
                switch (this.state.currentView) {
                    case 'kanban':
                        this.renderKanbanView();
                        break;
                    case 'calendar':
                        this.renderCalendarView();
                        break;
                    case 'timeline':
                        this.renderTimelineView();
                        break;
                    default:
                        this.renderTasks();
                        break;
                }
                this.renderStats();
                this.renderCategories();
                this.renderMiniCalendar();
                this.renderStatsWidget();
                this.renderAISuggestions();
                this.renderDailyChallenge();
            }

            renderCategories() {
                const categorySelect = document.getElementById('task-category');
                const categoryList = document.getElementById('category-list');

                // Mettre à jour le select des catégories
                categorySelect.innerHTML = '<option value="">Aucune catégorie</option>';
                this.state.categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category.id;
                    option.textContent = category.name;
                    categorySelect.appendChild(option);
                });

                // Mettre à jour la liste des catégories dans la sidebar
                categoryList.innerHTML = '';
                this.state.categories.forEach(category => {
                    const categoryItem = document.createElement('div');
                    categoryItem.className = 'category-item';
                    categoryItem.innerHTML = `
                        <div class="category-info" onclick="app.filterByCategory('${category.id}')">
                            <span class="category-color" style="background-color: ${category.color}"></span>
                            <span class="category-name">${category.name}</span>
                            <span class="category-count">${this.getTaskCountByCategory(category.id)}</span>
                        </div>
                        <button class="btn-icon" onclick="app.deleteCategory('${category.id}')" title="Supprimer"><i class="fas fa-trash"></i></button>
                    `;
                    categoryList.appendChild(categoryItem);
                });
            }

            getTaskCountByCategory(categoryId) {
                return this.state.tasks.filter(task => task.category === categoryId && !task.completed).length;
            }

            filterByCategory(categoryId) {
                this.state.currentFilter = 'category';
                this.state.selectedCategory = categoryId;
                this.render();
            }

            async deleteCategory(categoryId) {
                const confirmed = await this.confirm('Supprimer cette catégorie ? Les tâches associées ne seront pas supprimées.', 'Supprimer la catégorie');
                if (confirmed) {
                    this.state.categories = this.state.categories.filter(c => c.id !== categoryId);
                    // Retirer la catégorie des tâches
                    this.state.tasks.forEach(task => {
                        if (task.category === categoryId) {
                            task.category = null;
                        }
                    });
                    this.saveState();
                    this.render();
                    this.showNotification('Catégorie supprimée', 'info');
                }
            }

            renderTasks() {
                const container = document.getElementById('tasks-container');
                container.innerHTML = '';

                // Appliquer les filtres
                let filteredTasks = this.filterTasks(this.state.currentFilter);

                // Filtrage par catégorie si sélectionnée
                if (this.state.currentFilter === 'category' && this.state.selectedCategory) {
                    filteredTasks = filteredTasks.filter(task => task.category === this.state.selectedCategory);
                }

                // Tri des tâches
                filteredTasks = this.sortTasks(filteredTasks);

                if (filteredTasks.length === 0) {
                    const emptyMessage = this.state.currentFilter === 'all' ?
                        'Aucune tâche pour le moment' :
                        `Aucune tâche pour le filtre "${this.state.currentFilter}"`;

                    container.innerHTML = `
                        <div class="empty-state" role="status" aria-live="polite">
                            <p class="text-muted">${emptyMessage}</p>
                            <p class="text-xs text-muted">Commencez par ajouter votre première tâche !</p>
                        </div>
                    `;
                    return;
                }

                // Virtual scrolling pour les grandes listes
                if (filteredTasks.length > 50) {
                    this.renderVirtualizedTasks(filteredTasks, container);
                } else {
                    this.renderRegularTasks(filteredTasks, container);
                }

                // Annoncer le nombre de tâches aux lecteurs d'écran
                this.announceToScreenReader(`${filteredTasks.length} tâche${filteredTasks.length > 1 ? 's' : ''} affichée${filteredTasks.length > 1 ? 's' : ''}`);
            }

            renderRegularTasks(filteredTasks, container) {
                filteredTasks.forEach((task, index) => {
                    const taskElement = this.createTaskElement(task);

                    // Ajouter un délai d'animation basé sur l'index
                    taskElement.style.animationDelay = `${index * 0.1}s`;

                    container.appendChild(taskElement);

                    // Afficher les sous-tâches si elles existent
                    if (task.subtasks && task.subtasks.length > 0) {
                        task.subtasks.forEach((subtask, subIndex) => {
                            const subtaskElement = this.createSubtaskElement(subtask, task.id);
                            subtaskElement.style.animationDelay = `${(index * 0.1) + (subIndex * 0.05) + 0.05}s`;
                            container.appendChild(subtaskElement);
                        });
                    }
                });
            }

            renderVirtualizedTasks(filteredTasks, container) {
                // Implémentation simplifiée du virtual scrolling
                const itemHeight = 80; // Hauteur estimée d'une tâche
                const containerHeight = 400;
                const visibleItems = Math.ceil(containerHeight / itemHeight);
                const totalHeight = filteredTasks.length * itemHeight;

                container.style.height = `${containerHeight}px`;
                container.style.overflowY = 'auto';
                container.style.position = 'relative';

                const virtualContainer = document.createElement('div');
                virtualContainer.style.height = `${totalHeight}px`;
                virtualContainer.style.position = 'relative';

                let startIndex = 0;
                let endIndex = Math.min(visibleItems + 5, filteredTasks.length); // Buffer de 5 éléments

                const renderVisibleItems = () => {
                    virtualContainer.innerHTML = '';

                    for (let i = startIndex; i < endIndex; i++) {
                        const task = filteredTasks[i];
                        const taskElement = this.createTaskElement(task);
                        taskElement.style.position = 'absolute';
                        taskElement.style.top = `${i * itemHeight}px`;
                        taskElement.style.width = '100%';
                        virtualContainer.appendChild(taskElement);
                    }
                };

                container.appendChild(virtualContainer);
                renderVisibleItems();

                // Gérer le scroll pour le virtual scrolling
                container.addEventListener('scroll', this.throttle(() => {
                    const scrollTop = container.scrollTop;
                    const newStartIndex = Math.floor(scrollTop / itemHeight);
                    const newEndIndex = Math.min(newStartIndex + visibleItems + 5, filteredTasks.length);

                    if (newStartIndex !== startIndex || newEndIndex !== endIndex) {
                        startIndex = newStartIndex;
                        endIndex = newEndIndex;
                        renderVisibleItems();
                    }
                }, 16)); // 60fps
            }

            sortTasks(tasks) {
                return tasks.sort((a, b) => {
                    // Tâches non terminées en premier
                    if (a.completed !== b.completed) {
                        return a.completed ? 1 : -1;
                    }

                    // Puis par priorité
                    const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };
                    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
                    if (priorityDiff !== 0) return priorityDiff;

                    // Puis par date d'échéance
                    if (a.dueDate && b.dueDate) {
                        return new Date(a.dueDate) - new Date(b.dueDate);
                    }
                    if (a.dueDate) return -1;
                    if (b.dueDate) return 1;

                    // Enfin par date de création (plus récent en premier)
                    return new Date(b.createdAt) - new Date(a.createdAt);
                });
            }

            createTaskElement(task) {
                const div = document.createElement('div');
                let className = 'task-item animate-fade-in';

                // Ajouter la classe blocked si la tâche est bloquée par des dépendances
                if (!task.completed && !this.canCompleteTask(task)) {
                    className += ' blocked';
                }

                div.className = className;
                div.dataset.taskId = task.id;

                const priorityIcon = this.getPriorityIcon(task.priority);
                const priorityClass = `priority-${task.priority}`;
                const dueDateInfo = this.getDueDateInfo(task.dueDate);
                const categoryInfo = this.getCategoryInfo(task.category);

                div.innerHTML = `
                    <div class="task-content">
                        <div class="task-checkbox-container">
                            <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''}
                                   onchange="app.toggleTask('${task.id}')">
                        </div>
                        <div class="task-main">
                            <div class="task-header">
                                <span class="task-priority ${priorityClass}" title="Priorité ${task.priority}">
                                    ${priorityIcon}
                                </span>
                                <span class="task-title ${task.completed ? 'completed' : ''}">${task.title}</span>
                                ${categoryInfo}
                            </div>
                            ${task.description ? `<div class="task-description">${task.description}</div>` : ''}
                            ${dueDateInfo}
                            ${task.timeRange ? `<div class="task-time-range"><i class="fas fa-clock"></i> ${task.timeRange}</div>` : ''}
                            ${task.subtasks.length > 0 ? `<div class="task-subtasks-count">${task.subtasks.filter(st => st.completed).length}/${task.subtasks.length} sous-tâches</div>` : ''}
                            ${task.dependencies.length > 0 ? `<div class="task-dependencies"><i class="fas fa-link"></i> ${task.dependencies.length} dépendance(s)</div>` : ''}
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="btn-icon" onclick="app.addSubtask('${task.id}')" title="Ajouter sous-tâche"><i class="fas fa-plus"></i></button>
                        <button class="btn-icon" onclick="app.manageDependencies('${task.id}')" title="Gérer dépendances"><i class="fas fa-link"></i></button>
                        <button class="btn-icon" onclick="app.toggleFavorite('${task.id}')" title="Favoris">
                            <i class="fas ${task.favorite ? 'fa-star' : 'fa-star'}" style="color: ${task.favorite ? '#f59e0b' : '#94a3b8'}"></i>
                        </button>
                        <button class="btn-icon" onclick="app.editTask('${task.id}')" title="Modifier"><i class="fas fa-edit"></i></button>
                        <button class="btn-icon" onclick="app.duplicateTask('${task.id}')" title="Dupliquer"><i class="fas fa-copy"></i></button>
                        <button class="btn-icon" onclick="app.deleteTask('${task.id}')" title="Supprimer"><i class="fas fa-trash"></i></button>
                    </div>
                `;

                // Ajouter les événements de glisser-déposer
                div.draggable = true;
                div.addEventListener('dragstart', (e) => this.handleDragStart(e, task));
                div.addEventListener('dragover', (e) => this.handleDragOver(e));
                div.addEventListener('drop', (e) => this.handleDrop(e, task));

                return div;
            }

            getPriorityIcon(priority) {
                const icons = {
                    critical: '🔴',
                    high: '🟠',
                    normal: '🔵',
                    low: '🟢'
                };
                return icons[priority] || icons.normal;
            }

            getDueDateInfo(dueDate) {
                if (!dueDate) return '';

                const due = new Date(dueDate);
                const now = new Date();
                const diffDays = Math.ceil((due - now) / (1000 * 60 * 60 * 24));

                let dueDateClass = 'due-date';
                let dueDateText = due.toLocaleDateString('fr-FR');

                if (diffDays < 0) {
                    dueDateClass += ' overdue';
                    dueDateText = `En retard (${Math.abs(diffDays)} jours)`;
                } else if (diffDays === 0) {
                    dueDateClass += ' due-today';
                    dueDateText = 'Aujourd\'hui';
                } else if (diffDays === 1) {
                    dueDateClass += ' due-tomorrow';
                    dueDateText = 'Demain';
                } else if (diffDays <= 7) {
                    dueDateClass += ' due-soon';
                }

                return `<div class="${dueDateClass}">📅 ${dueDateText}</div>`;
            }

            getCategoryInfo(categoryId) {
                if (!categoryId) return '';
                const category = this.state.categories.find(c => c.id === categoryId);
                if (!category) return '';

                return `<span class="task-category" style="background-color: ${category.color}20; color: ${category.color}; border: 1px solid ${category.color}40;">
                    ${category.name}
                </span>`;
            }

            toggleTask(id) {
                const task = this.state.tasks.find(t => t.id === id);
                if (task) {
                    const taskElement = document.querySelector(`[data-task-id="${id}"]`);

                    // Vérifier les dépendances avant de marquer comme terminée
                    if (!task.completed && !this.canCompleteTask(task)) {
                        const blockedBy = task.dependencies
                            .map(depId => this.state.tasks.find(t => t.id === depId))
                            .filter(depTask => depTask && !depTask.completed)
                            .map(depTask => depTask.title);

                        this.showNotification(`Tâche bloquée par: ${blockedBy.join(', ')}`, 'warning');
                        return;
                    }

                    task.completed = !task.completed;
                    task.updatedAt = new Date().toISOString();

                    if (task.completed) {
                        task.completedAt = new Date().toISOString();
                taskElement.classList.add('completing');

                // Animation de célébration plus discrète
                setTimeout(() => {
                    taskElement.classList.add('celebrating');
                    setTimeout(() => {
                        taskElement.classList.remove('celebrating');
                    }, 800);
                }, 200);                        // Ajouter des points de gamification
                        this.addPoints(this.calculateTaskPoints(task));

                        // Créer une nouvelle tâche récurrente si nécessaire
                        if (task.recurring) {
                            setTimeout(() => {
                                this.createRecurringTask(task);
                            }, 1000);
                        }
                    } else {
                        delete task.completedAt;
                    }

                    setTimeout(() => {
                        taskElement.classList.remove('completing');
                        this.saveState();
                        this.render();
                    }, 500);
                }
            }

            deleteTask(id) {
                const taskElement = document.querySelector(`[data-task-id="${id}"]`);
                const task = this.state.tasks.find(t => t.id === id);
                
                if (taskElement) {
                    taskElement.classList.add('deleting');
                }

                setTimeout(() => {
                    this.state.tasks = this.state.tasks.filter(t => t.id !== id);
                    this.saveState();
                    this.render();
                    this.showNotification('Tâche supprimée', 'info');
                }, 300);
            }

            duplicateTask(id) {
                const originalTask = this.state.tasks.find(t => t.id === id);
                if (originalTask) {
                    const duplicatedTask = {
                        ...originalTask,
                        id: Date.now().toString(),
                        title: `${originalTask.title} (copie)`,
                        completed: false,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };

                    delete duplicatedTask.completedAt;

                    this.state.tasks.unshift(duplicatedTask);
                    this.saveState();
                    this.render();
                    this.showNotification('Tâche dupliquée', 'success');
                }
            }

            toggleFavorite(id) {
                const task = this.state.tasks.find(t => t.id === id);
                if (task) {
                    task.favorite = !task.favorite;
                    task.updatedAt = new Date().toISOString();
                    this.saveState();
                    this.render();
                    this.showNotification(task.favorite ? 'Ajouté aux favoris ⭐' : 'Retiré des favoris', 'info');
                }
            }

            async editTask(id) {
                const task = this.state.tasks.find(t => t.id === id);
                if (task) {
                    const newTitle = await this.prompt('Modifier le titre de la tâche:', task.title, 'Modifier la tâche');
                    if (newTitle && newTitle.trim() !== task.title) {
                        task.title = newTitle.trim();
                        task.updatedAt = new Date().toISOString();
                        this.saveState();
                        this.render();
                        this.showNotification('Tâche modifiée', 'success');
                    }
                }
            }

            calculateTaskPoints(task) {
                let points = 10; // Points de base

                // Bonus selon la priorité
                const priorityBonus = {
                    critical: 50,
                    high: 30,
                    normal: 10,
                    low: 5
                };
                points += priorityBonus[task.priority] || 10;

                // Bonus pour les sous-tâches
                points += task.subtasks.length * 5;

                // Bonus si terminé à temps
                if (task.dueDate && new Date(task.dueDate) >= new Date()) {
                    points += 20;
                }

                return points;
            }

            addPoints(points) {
                if (!this.state.gamification) {
                    this.state.gamification = {
                        totalPoints: 0,
                        level: 1,
                        badges: [],
                        achievements: [],
                        streakRecord: 0
                    };
                }

                const oldLevel = this.state.gamification.level;
                this.state.gamification.totalPoints += points;

                // Calcul du niveau (100 points par niveau)
                const newLevel = Math.floor(this.state.gamification.totalPoints / 100) + 1;
                if (newLevel > this.state.gamification.level) {
                    this.state.gamification.level = newLevel;
                    this.showNotification(`Niveau ${newLevel} atteint ! 🎊`, 'success');
                    this.checkForNewBadges();
                }

                // Vérifier les nouveaux badges
                this.checkForNewBadges();
            }

            checkForNewBadges() {
                const badges = this.getAvailableBadges();
                const currentBadges = this.state.gamification.badges || [];

                badges.forEach(badge => {
                    if (!currentBadges.find(b => b.id === badge.id) && badge.condition()) {
                        currentBadges.push({
                            ...badge,
                            earnedAt: new Date().toISOString(),
                            isNew: true
                        });

                        this.showNotification(`Nouveau badge débloqué: ${badge.name} ${badge.icon}`, 'success');

                        // Retirer le flag "nouveau" après 5 secondes
                        setTimeout(() => {
                            const badgeIndex = currentBadges.findIndex(b => b.id === badge.id);
                            if (badgeIndex !== -1) {
                                currentBadges[badgeIndex].isNew = false;
                                this.saveState();
                            }
                        }, 5000);
                    }
                });

                this.state.gamification.badges = currentBadges;
            }

            getAvailableBadges() {
                const stats = this.calculateStats();
                const streak = this.calculateStreak();
                const totalCompleted = this.state.tasks.filter(t => t.completed).length;
                const highPriorityCompleted = this.state.tasks.filter(t =>
                    t.completed && (t.priority === 'high' || t.priority === 'critical')
                ).length;

                return [
                    {
                        id: 'first_task',
                        name: 'Premier pas',
                        description: 'Terminez votre première tâche',
                        icon: '🎯',
                        condition: () => totalCompleted >= 1
                    },
                    {
                        id: 'task_master_10',
                        name: 'Maître des tâches',
                        description: 'Terminez 10 tâches',
                        icon: '🏅',
                        condition: () => totalCompleted >= 10
                    },
                    {
                        id: 'task_master_50',
                        name: 'Expert productivité',
                        description: 'Terminez 50 tâches',
                        icon: '🏆',
                        condition: () => totalCompleted >= 50
                    },
                    {
                        id: 'task_master_100',
                        name: 'Légende',
                        description: 'Terminez 100 tâches',
                        icon: '💎',
                        condition: () => totalCompleted >= 100
                    },
                    {
                        id: 'streak_3',
                        name: 'Régularité',
                        description: 'Maintenez une série de 3 jours',
                        icon: '🔥',
                        condition: () => streak >= 3
                    },
                    {
                        id: 'streak_7',
                        name: 'Persévérance',
                        description: 'Maintenez une série de 7 jours',
                        icon: '⚡',
                        condition: () => streak >= 7
                    },
                    {
                        id: 'streak_30',
                        name: 'Discipline de fer',
                        description: 'Maintenez une série de 30 jours',
                        icon: '👑',
                        condition: () => streak >= 30
                    },
                    {
                        id: 'priority_master',
                        name: 'Maître des priorités',
                        description: 'Terminez 20 tâches de haute priorité',
                        icon: '🎯',
                        condition: () => highPriorityCompleted >= 20
                    },
                    {
                        id: 'organizer',
                        name: 'Organisateur',
                        description: 'Créez 5 catégories',
                        icon: '📂',
                        condition: () => this.state.categories.length >= 5
                    },
                    {
                        id: 'pomodoro_master',
                        name: 'Maître Pomodoro',
                        description: 'Terminez 10 sessions Pomodoro',
                        icon: '🍅',
                        condition: () => (this.state.totalPomodoroSessions || 0) >= 10
                    },
                    {
                        id: 'early_bird',
                        name: 'Lève-tôt',
                        description: 'Terminez une tâche avant 8h',
                        icon: '🌅',
                        condition: () => this.state.tasks.some(task => {
                            if (!task.completed || !task.completedAt) return false;
                            const completedTime = new Date(task.completedAt);
                            return completedTime.getHours() < 8;
                        })
                    },
                    {
                        id: 'night_owl',
                        name: 'Couche-tard',
                        description: 'Terminez une tâche après 22h',
                        icon: '🦉',
                        condition: () => this.state.tasks.some(task => {
                            if (!task.completed || !task.completedAt) return false;
                            const completedTime = new Date(task.completedAt);
                            return completedTime.getHours() >= 22;
                        })
                    }
                ];
            }

            // Fonctions de drag and drop
            handleDragStart(e, task) {
                e.dataTransfer.setData('text/plain', task.id);
                e.target.classList.add('dragging');
            }

            handleDragOver(e) {
                e.preventDefault();
                e.target.closest('.task-item')?.classList.add('drag-over');
            }

            handleDrop(e, targetTask) {
                e.preventDefault();
                const draggedTaskId = e.dataTransfer.getData('text/plain');
                const draggedTask = this.state.tasks.find(t => t.id === draggedTaskId);

                if (draggedTask && draggedTask.id !== targetTask.id) {
                    // Réorganiser les tâches
                    const draggedIndex = this.state.tasks.indexOf(draggedTask);
                    const targetIndex = this.state.tasks.indexOf(targetTask);

                    this.state.tasks.splice(draggedIndex, 1);
                    this.state.tasks.splice(targetIndex, 0, draggedTask);

                    this.saveState();
                    this.render();
                    this.showNotification('Tâche déplacée', 'info');
                }

                // Nettoyer les classes
                document.querySelectorAll('.task-item').forEach(item => {
                    item.classList.remove('dragging', 'drag-over');
                });
            }

            renderStats() {
                const total = this.state.tasks.length;
                const completed = this.state.tasks.filter(t => t.completed).length;
                const pending = total - completed;
                const overdue = this.state.tasks.filter(t =>
                    t.dueDate && new Date(t.dueDate) < new Date() && !t.completed
                ).length;

                let statsHtml = `<span class="text-sm text-muted">${total} tâches`;
                if (completed > 0) statsHtml += ` • ${completed} terminées`;
                if (overdue > 0) statsHtml += ` • <span style="color: var(--danger-color)">${overdue} en retard</span>`;
                statsHtml += '</span>';

                // Ajouter les points de gamification si disponibles
                if (this.state.gamification) {
                    const currentXP = this.state.gamification.totalPoints % 100;
                    const nextLevelXP = 100;

                    statsHtml += ` • <span class="level-indicator">
                        ⭐ Niveau ${this.state.gamification.level}
                        <div class="xp-bar">
                            <div class="xp-progress" style="width: ${(currentXP / nextLevelXP) * 100}%"></div>
                        </div>
                    </span>`;

                    // Afficher les badges récents
                    const recentBadges = (this.state.gamification.badges || [])
                        .filter(badge => badge.isNew)
                        .slice(0, 2);

                    if (recentBadges.length > 0) {
                        statsHtml += '<br><div style="margin-top: 4px;">';
                        recentBadges.forEach(badge => {
                            statsHtml += `<span class="badge new">${badge.icon} ${badge.name}</span>`;
                        });
                        statsHtml += '</div>';
                    }
                }

                document.getElementById('stats-summary').innerHTML = statsHtml;
            }

            // Fonction de recherche
            searchTasks(query) {
                const searchTerm = query.toLowerCase();
                return this.state.tasks.filter(task =>
                    task.title.toLowerCase().includes(searchTerm) ||
                    (task.description && task.description.toLowerCase().includes(searchTerm)) ||
                    task.tags.some(tag => tag.toLowerCase().includes(searchTerm))
                );
            }

            // Fonction de filtrage
            filterTasks(filter) {
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);

                switch (filter) {
                    case 'today':
                        return this.state.tasks.filter(task => {
                            if (!task.dueDate) return false;
                            const dueDate = new Date(task.dueDate);
                            return dueDate >= today && dueDate < tomorrow;
                        });
                    case 'upcoming':
                        return this.state.tasks.filter(task => {
                            if (!task.dueDate) return false;
                            return new Date(task.dueDate) > tomorrow;
                        });
                    case 'overdue':
                        return this.state.tasks.filter(task => {
                            if (!task.dueDate || task.completed) return false;
                            return new Date(task.dueDate) < today;
                        });
                    case 'completed':
                        return this.state.tasks.filter(task => task.completed);
                    case 'favorites':
                        return this.state.tasks.filter(task => task.favorite);
                    case 'high-priority':
                        return this.state.tasks.filter(task => task.priority === 'high' || task.priority === 'critical');
                    case 'category':
                        // Le filtrage par catégorie spécifique est géré dans renderTasks
                        return this.state.tasks;
                    case 'date':
                        // Filtrage par date sélectionnée dans le calendrier
                        if (this.state.selectedDate) {
                            return this.state.tasks.filter(task => task.dueDate === this.state.selectedDate);
                        }
                        return this.state.tasks;
                    case 'search':
                        // Filtrage par recherche
                        if (this.state.searchQuery) {
                            return this.searchTasks(this.state.searchQuery);
                        }
                        return this.state.tasks;
                    default:
                        return this.state.tasks;
                }
            }

            // Initialisation des catégories par défaut
            initDefaultCategories() {
                if (this.state.categories.length === 0) {
                    const defaultCategories = [
                        { id: 'work', name: 'Travail', color: '#3b82f6' },
                        { id: 'personal', name: 'Personnel', color: '#10b981' },
                        { id: 'shopping', name: 'Courses', color: '#f59e0b' },
                        { id: 'health', name: 'Santé', color: '#ef4444' }
                    ];

                    defaultCategories.forEach(cat => {
                        cat.id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
                        cat.createdAt = new Date().toISOString();
                    });

                    this.state.categories = defaultCategories;
                    this.saveState();
                }
            }

            // Initialisation du calendrier
            initCalendar() {
                // S'assurer que le calendrier affiche toujours le mois actuel
                this.state.calendarDate = new Date();
                this.saveState();
            }

            // Gestion du calendrier
            renderMiniCalendar() {
                const calendarContainer = document.getElementById('mini-calendar');
                if (!calendarContainer) return;

                // S'assurer que la date du calendrier est toujours définie sur aujourd'hui par défaut
                if (!this.state.calendarDate) {
                    this.state.calendarDate = new Date();
                }
                const currentDate = new Date(this.state.calendarDate);

                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const startDate = new Date(firstDay);
                startDate.setDate(startDate.getDate() - firstDay.getDay());

                const monthNames = [
                    'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
                    'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
                ];

                const dayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];

                let calendarHTML = `
                    <div class="calendar-header">
                        <button class="calendar-nav" onclick="app.changeCalendarMonth(-1)">‹</button>
                        <div class="calendar-month">${monthNames[month]} ${year}</div>
                        <button class="calendar-nav" onclick="app.changeCalendarMonth(1)">›</button>
                    </div>
                    <div class="calendar-controls">
                        <button class="btn btn-secondary text-xs" onclick="app.goToToday()" title="Aller à aujourd'hui">Aujourd'hui</button>
                    </div>
                    <div class="calendar-grid">
                `;

                // En-têtes des jours
                dayNames.forEach(day => {
                    calendarHTML += `<div class="calendar-day-header">${day}</div>`;
                });

                // Jours du calendrier
                const today = new Date();
                for (let i = 0; i < 42; i++) {
                    const date = new Date(startDate);
                    date.setDate(startDate.getDate() + i);

                    const isToday = date.toDateString() === today.toDateString();
                    const isCurrentMonth = date.getMonth() === month;
                    const hasTasks = this.getTasksForDate(date).length > 0;

                    let dayClass = 'calendar-day';
                    if (isToday) dayClass += ' today';
                    if (!isCurrentMonth) dayClass += ' other-month';
                    if (hasTasks) dayClass += ' has-tasks';

                    calendarHTML += `
                        <div class="${dayClass}" onclick="app.selectCalendarDate('${date.toISOString()}')">
                            ${date.getDate()}
                        </div>
                    `;
                }

                calendarHTML += '</div>';
                calendarContainer.innerHTML = calendarHTML;
            }

            changeCalendarMonth(direction) {
                const currentDate = this.state.calendarDate ? new Date(this.state.calendarDate) : new Date();
                currentDate.setMonth(currentDate.getMonth() + direction);
                this.state.calendarDate = currentDate;
                this.renderMiniCalendar();
                this.saveState();
            }

            goToToday() {
                this.state.calendarDate = new Date();
                this.renderMiniCalendar();
                this.saveState();
                this.showNotification('Calendrier mis à jour sur aujourd\'hui', 'info');
            }

            selectCalendarDate(dateString) {
                const selectedDate = new Date(dateString);
                this.state.selectedDate = selectedDate.toISOString().split('T')[0];
                this.state.currentFilter = 'date';
                this.render();
                this.showNotification(`Tâches du ${selectedDate.toLocaleDateString('fr-FR')}`, 'info');
            }

            getTasksForDate(date) {
                const dateString = date.toISOString().split('T')[0];
                return this.state.tasks.filter(task => {
                    if (!task.dueDate) return false;
                    return task.dueDate === dateString;
                });
            }

            // Gestion des tâches récurrentes
            createRecurringTask(originalTask) {
                if (!originalTask.recurring || !originalTask.dueDate) return;

                const dueDate = new Date(originalTask.dueDate);
                let nextDate = new Date(dueDate);

                switch (originalTask.recurring) {
                    case 'daily':
                        nextDate.setDate(nextDate.getDate() + 1);
                        break;
                    case 'weekly':
                        nextDate.setDate(nextDate.getDate() + 7);
                        break;
                    case 'monthly':
                        nextDate.setMonth(nextDate.getMonth() + 1);
                        break;
                    default:
                        return;
                }

                const newTask = {
                    ...originalTask,
                    id: Date.now().toString(),
                    completed: false,
                    dueDate: nextDate.toISOString().split('T')[0],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                delete newTask.completedAt;

                this.state.tasks.unshift(newTask);
                this.saveState();
                this.showNotification('Tâche récurrente créée !', 'success');
            }

            // Gestion des sous-tâches
            createSubtaskElement(subtask, parentId) {
                const div = document.createElement('div');
                div.className = 'subtask-item animate-fade-in';
                div.dataset.subtaskId = subtask.id;
                div.dataset.parentId = parentId;

                div.innerHTML = `
                    <div class="subtask-content">
                        <div class="subtask-indent"></div>
                        <div class="task-checkbox-container">
                            <input type="checkbox" class="task-checkbox" ${subtask.completed ? 'checked' : ''}
                                   onchange="app.toggleSubtask('${parentId}', '${subtask.id}')">
                        </div>
                        <div class="subtask-main">
                            <span class="task-title ${subtask.completed ? 'completed' : ''}">${subtask.title}</span>
                            ${subtask.description ? `<div class="task-description">${subtask.description}</div>` : ''}
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="btn-icon" onclick="app.editSubtask('${parentId}', '${subtask.id}')" title="Modifier">✏️</button>
                        <button class="btn-icon" onclick="app.deleteSubtask('${parentId}', '${subtask.id}')" title="Supprimer">🗑️</button>
                    </div>
                `;

                return div;
            }

            async addSubtask(parentId) {
                const title = await this.prompt('Titre de la sous-tâche:', '', 'Nouvelle sous-tâche');
                if (title && title.trim()) {
                    const parentTask = this.state.tasks.find(t => t.id === parentId);
                    if (parentTask) {
                        const subtask = {
                            id: Date.now().toString(),
                            title: title.trim(),
                            description: '',
                            completed: false,
                            createdAt: new Date().toISOString()
                        };

                        if (!parentTask.subtasks) {
                            parentTask.subtasks = [];
                        }

                        parentTask.subtasks.push(subtask);
                        parentTask.updatedAt = new Date().toISOString();

                        this.saveState();
                        this.render();
                        this.showNotification('Sous-tâche ajoutée !', 'success');
                    }
                }
            }

            toggleSubtask(parentId, subtaskId) {
                const parentTask = this.state.tasks.find(t => t.id === parentId);
                if (parentTask) {
                    const subtask = parentTask.subtasks.find(st => st.id === subtaskId);
                    if (subtask) {
                        subtask.completed = !subtask.completed;
                        subtask.updatedAt = new Date().toISOString();
                        parentTask.updatedAt = new Date().toISOString();

                        // Vérifier si toutes les sous-tâches sont terminées
                        const allSubtasksCompleted = parentTask.subtasks.every(st => st.completed);
                        if (allSubtasksCompleted && parentTask.subtasks.length > 0) {
                            this.showNotification('Toutes les sous-tâches terminées ! 🎉', 'success');
                        }

                        this.saveState();
                        this.render();
                    }
                }
            }

            async editSubtask(parentId, subtaskId) {
                const parentTask = this.state.tasks.find(t => t.id === parentId);
                if (parentTask) {
                    const subtask = parentTask.subtasks.find(st => st.id === subtaskId);
                    if (subtask) {
                        const newTitle = await this.prompt('Modifier le titre de la sous-tâche:', subtask.title, 'Modifier la sous-tâche');
                        if (newTitle && newTitle.trim() !== subtask.title) {
                            subtask.title = newTitle.trim();
                            subtask.updatedAt = new Date().toISOString();
                            parentTask.updatedAt = new Date().toISOString();

                            this.saveState();
                            this.render();
                            this.showNotification('Sous-tâche modifiée', 'success');
                        }
                    }
                }
            }

            async deleteSubtask(parentId, subtaskId) {
                const confirmed = await this.confirm('Supprimer cette sous-tâche ?', 'Supprimer la sous-tâche');
                if (confirmed) {
                    const parentTask = this.state.tasks.find(t => t.id === parentId);
                    if (parentTask) {
                        parentTask.subtasks = parentTask.subtasks.filter(st => st.id !== subtaskId);
                        parentTask.updatedAt = new Date().toISOString();

                        this.saveState();
                        this.render();
                        this.showNotification('Sous-tâche supprimée', 'info');
                    }
                }
            }

            // Gestion des dépendances
            async manageDependencies(taskId) {
                const task = this.state.tasks.find(t => t.id === taskId);
                if (!task) return;

                const availableTasks = this.state.tasks.filter(t =>
                    t.id !== taskId && !t.completed && !this.hasDependencyLoop(taskId, t.id)
                );

                if (availableTasks.length === 0) {
                    this.alert('Aucune tâche disponible pour créer une dépendance.', 'Dépendances');
                    return;
                }

                let options = 'Tâches disponibles:\n';
                availableTasks.forEach((t, index) => {
                    options += `${index + 1}. ${t.title}\n`;
                });

                const choice = await this.prompt(options + '\n\nEntrez le numéro de la tâche dont cette tâche dépend (0 pour annuler):', '', 'Ajouter une dépendance');
                const choiceNum = parseInt(choice);

                if (choiceNum > 0 && choiceNum <= availableTasks.length) {
                    const dependencyTask = availableTasks[choiceNum - 1];

                    if (!task.dependencies) {
                        task.dependencies = [];
                    }

                    if (!task.dependencies.includes(dependencyTask.id)) {
                        task.dependencies.push(dependencyTask.id);
                        task.updatedAt = new Date().toISOString();

                        this.saveState();
                        this.render();
                        this.showNotification(`Dépendance ajoutée: ${dependencyTask.title}`, 'success');
                    } else {
                        this.showNotification('Cette dépendance existe déjà', 'info');
                    }
                }
            }

            hasDependencyLoop(taskId, dependencyId) {
                // Vérifier s'il y aurait une boucle de dépendances
                const dependencyTask = this.state.tasks.find(t => t.id === dependencyId);
                if (!dependencyTask || !dependencyTask.dependencies) return false;

                return dependencyTask.dependencies.includes(taskId) ||
                    dependencyTask.dependencies.some(depId => this.hasDependencyLoop(taskId, depId));
            }

            canCompleteTask(task) {
                // Vérifier si toutes les dépendances sont terminées
                if (!task.dependencies || task.dependencies.length === 0) return true;

                return task.dependencies.every(depId => {
                    const depTask = this.state.tasks.find(t => t.id === depId);
                    return depTask && depTask.completed;
                });
            }

            getBlockedTasks() {
                // Retourner les tâches bloquées par des dépendances
                return this.state.tasks.filter(task =>
                    !task.completed && !this.canCompleteTask(task)
                );
            }

            // Fonctionnalités de productivité

            // Recherche avancée
            handleSearch(e) {
                const query = e.target.value.trim();
                this.searchDebounce(query);
            }

            performSearch(query) {
                this.state.searchQuery = query;

                if (query) {
                    this.state.currentFilter = 'search';
                    this.announceToScreenReader(`${this.searchTasks(query).length} résultats trouvés pour "${query}"`);
                } else {
                    this.state.currentFilter = 'all';
                }

                this.render();
            }

            clearSearch() {
                document.getElementById('search-input').value = '';
                this.state.searchQuery = '';
                this.state.currentFilter = 'all';
                this.render();
            }

            // Timer Pomodoro
            togglePomodoroTimer() {
                if (!this.state.pomodoro) {
                    this.state.pomodoro = {
                        isRunning: false,
                        timeLeft: 25 * 60, // 25 minutes en secondes
                        isBreak: false,
                        interval: null
                    };
                }

                const pomodoro = this.state.pomodoro;
                const timerElement = document.getElementById('pomodoro-timer');
                const toggleBtn = document.getElementById('timer-toggle');

                if (pomodoro.isRunning) {
                    // Arrêter le timer
                    clearInterval(pomodoro.interval);
                    pomodoro.isRunning = false;
                    toggleBtn.innerHTML = '<i class="fas fa-play"></i>';
                    timerElement.classList.remove('active');
                    this.showNotification('Timer en pause', 'info');
                } else {
                    // Démarrer le timer
                    pomodoro.isRunning = true;
                    toggleBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    timerElement.classList.add('active');

                    pomodoro.interval = setInterval(() => {
                        pomodoro.timeLeft--;
                        this.updateTimerDisplay();

                        if (pomodoro.timeLeft <= 0) {
                            this.pomodoroComplete();
                        }
                    }, 1000);

                    this.showNotification('Timer Pomodoro démarré !', 'success');
                }
            }

            updateTimerDisplay() {
                const pomodoro = this.state.pomodoro;
                const minutes = Math.floor(pomodoro.timeLeft / 60);
                const seconds = pomodoro.timeLeft % 60;
                const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                document.getElementById('timer-display').textContent = display;

                // Changer le titre de la page pour afficher le timer
                if (pomodoro.isRunning) {
                    document.title = `${display} - TodoList Pro`;
                } else {
                    document.title = 'TodoList Pro';
                }
            }

            pomodoroComplete() {
                const pomodoro = this.state.pomodoro;
                clearInterval(pomodoro.interval);
                pomodoro.isRunning = false;

                const toggleBtn = document.getElementById('timer-toggle');
                const timerElement = document.getElementById('pomodoro-timer');

                toggleBtn.innerHTML = '<i class="fas fa-play"></i>';
                timerElement.classList.remove('active');

                if (pomodoro.isBreak) {
                    // Fin de la pause, retour au travail
                    pomodoro.timeLeft = 25 * 60;
                    pomodoro.isBreak = false;
                    this.showNotification('Pause terminée ! Retour au travail 💪', 'success');
                } else {
                    // Fin du travail, début de la pause
                    pomodoro.timeLeft = 5 * 60; // 5 minutes de pause
                    pomodoro.isBreak = true;
                    this.showNotification('Pomodoro terminé ! Prenez une pause ☕', 'success');

                    // Compter les sessions Pomodoro
                    this.state.totalPomodoroSessions = (this.state.totalPomodoroSessions || 0) + 1;
                    this.state.pomodoroSessionsToday = (this.state.pomodoroSessionsToday || 0) + 1;

                    // Ajouter des points de gamification
                    this.addPoints(50);
                }

                this.updateTimerDisplay();
                document.title = 'TodoList Pro';
            }

            // Mode Focus
            toggleFocusMode() {
                document.body.classList.toggle('focus-mode');
                const isActive = document.body.classList.contains('focus-mode');

                if (isActive) {
                    this.showNotification('Mode Focus activé', 'success');
                    document.getElementById('focus-mode-toggle').innerHTML = '<i class="fas fa-arrow-left"></i>';
                } else {
                    this.showNotification('Mode Focus désactivé', 'info');
                    document.getElementById('focus-mode-toggle').innerHTML = '<i class="fas fa-bullseye"></i>';
                }
            }

            // Système de thèmes et personnalisation

            showSettings() {
                const settingsHTML = `
                    <div class="modal-content" style="max-width: 500px; margin: 50px auto; background: var(--bg-primary); padding: var(--spacing-xl); border-radius: var(--border-radius-lg); box-shadow: var(--shadow-lg);">
                        <h2 style="margin-bottom: var(--spacing-lg);">⚙️ Paramètres</h2>

                        <div class="settings-section">
                            <h3>🎨 Thèmes</h3>
                            <div class="theme-selector" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: var(--spacing-md); margin: var(--spacing-md) 0;">
                                <button class="theme-btn ${this.state.theme === 'light' ? 'active' : ''}" onclick="app.setTheme('light')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: var(--border-radius); background: white; cursor: pointer;">
                                    ☀️ Clair
                                </button>
                                <button class="theme-btn ${this.state.theme === 'dark' ? 'active' : ''}" onclick="app.setTheme('dark')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: var(--border-radius); background: #1e293b; color: white; cursor: pointer;">
                                    🌙 Sombre
                                </button>
                                <button class="theme-btn ${this.state.theme === 'colorful' ? 'active' : ''}" onclick="app.setTheme('colorful')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: var(--border-radius); background: linear-gradient(45deg, #667eea, #764ba2); color: white; cursor: pointer;">
                                    🌈 Coloré
                                </button>
                                <button class="theme-btn ${this.state.theme === 'minimal' ? 'active' : ''}" onclick="app.setTheme('minimal')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: 0; background: #fafafa; cursor: pointer;">
                                    ⚪ Minimal
                                </button>
                                <button class="theme-btn ${this.state.theme === 'nature' ? 'active' : ''}" onclick="app.setTheme('nature')" style="padding: var(--spacing-md); border: 2px solid var(--bg-tertiary); border-radius: var(--border-radius); background: linear-gradient(45deg, #a8e6cf, #dcedc1); cursor: pointer;">
                                    🌿 Nature
                                </button>
                            </div>
                        </div>

                        <div class="settings-section" style="margin-top: var(--spacing-lg);">
                            <h3>🧘 Modes spéciaux</h3>
                            <div style="margin: var(--spacing-md) 0;">
                                <button class="btn ${document.body.classList.contains('zen-mode') ? 'btn-primary' : 'btn-secondary'}" onclick="app.toggleZenMode()">
                                    🧘 Mode Zen
                                </button>
                                <button class="btn ${document.body.classList.contains('focus-mode') ? 'btn-primary' : 'btn-secondary'}" onclick="app.toggleFocusMode()" style="margin-left: var(--spacing-sm);">
                                    🎯 Mode Focus
                                </button>
                            </div>
                        </div>

                        <div class="settings-section" style="margin-top: var(--spacing-lg);">
                            <h3>📊 Données</h3>
                            <div style="margin: var(--spacing-md) 0;">
                                <button class="btn btn-secondary" onclick="app.exportData()">
                                    📤 Exporter les données
                                </button>
                                <button class="btn btn-secondary" onclick="app.importData()" style="margin-left: var(--spacing-sm);">
                                    📥 Importer les données
                                </button>
                                <button class="btn" onclick="app.resetData()" style="margin-left: var(--spacing-sm); background: var(--danger-color); color: white;">
                                    🗑️ Réinitialiser
                                </button>
                            </div>
                        </div>

                        <div style="margin-top: var(--spacing-xl); text-align: center;">
                            <button class="btn btn-primary" onclick="app.closeSettings()">
                                Fermer
                            </button>
                        </div>
                    </div>
                `;

                const overlay = document.getElementById('modal-overlay');
                overlay.innerHTML = settingsHTML;
                overlay.classList.remove('hidden');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
            }

            closeSettings() {
                document.getElementById('modal-overlay').classList.add('hidden');
            }

            toggleZenMode() {
                document.body.classList.toggle('zen-mode');
                const isActive = document.body.classList.contains('zen-mode');

                if (isActive) {
                    this.showNotification('Mode Zen activé 🧘', 'success');
                } else {
                    this.showNotification('Mode Zen désactivé', 'info');
                }

                this.closeSettings();
            }

            exportData() {
                const data = {
                    tasks: this.state.tasks,
                    categories: this.state.categories,
                    settings: this.state.settings,
                    exportDate: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `todolist-backup-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.showNotification('Données exportées !', 'success');
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const data = JSON.parse(e.target.result);
                                if (data.tasks && data.categories) {
                                    this.state.tasks = data.tasks;
                                    this.state.categories = data.categories;
                                    if (data.settings) this.state.settings = data.settings;

                                    this.saveState();
                                    this.render();
                                    this.showNotification('Données importées !', 'success');
                                    this.closeSettings();
                                } else {
                                    throw new Error('Format invalide');
                                }
                            } catch (error) {
                                this.showNotification('Erreur lors de l\'importation', 'error');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }

            async resetData() {
                const confirmed = await this.confirm('Êtes-vous sûr de vouloir supprimer toutes les données ? Cette action est irréversible.', 'Réinitialiser les données');
                if (confirmed) {
                    this.state.tasks = [];
                    this.state.categories = [];
                    this.state.settings = {};
                    this.initDefaultCategories();
                    this.saveState();
                    this.render();
                    this.showNotification('Données réinitialisées', 'info');
                    this.closeSettings();
                }
            }

            // Système de statistiques et suivi

            renderStatsWidget() {
                const statsContainer = document.getElementById('stats-widget');
                if (!statsContainer) return;

                const stats = this.calculateStats();
                const streak = this.calculateStreak();

                let statsHTML = '';

                // Streak actuel
                if (streak > 0) {
                    statsHTML += `
                        <div class="stat-item">
                            <span class="stat-label">Série actuelle</span>
                            <span class="streak-indicator">🔥 ${streak} jour${streak > 1 ? 's' : ''}</span>
                        </div>
                    `;
                }

                // Tâches terminées aujourd'hui
                statsHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Aujourd'hui</span>
                        <span class="stat-value">${stats.todayCompleted}</span>
                    </div>
                `;

                // Taux de completion cette semaine
                const completionRate = stats.weekTotal > 0 ? Math.round((stats.weekCompleted / stats.weekTotal) * 100) : 0;
                statsHTML += `
                    <div class="stat-item">
                        <span class="stat-label">Taux semaine</span>
                        <span class="stat-value">${completionRate}%</span>
                    </div>
                `;

                // Graphique de productivité des 7 derniers jours
                statsHTML += '<div class="productivity-chart" id="mini-chart"></div>';

                statsContainer.innerHTML = statsHTML;

                // Générer le mini graphique
                this.renderMiniChart();
            }

            calculateStats() {
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const weekAgo = new Date(today);
                weekAgo.setDate(weekAgo.getDate() - 7);

                const todayCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    const completedDate = new Date(task.completedAt);
                    return completedDate >= today;
                }).length;

                const weekCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    const completedDate = new Date(task.completedAt);
                    return completedDate >= weekAgo;
                }).length;

                const weekTotal = this.state.tasks.filter(task => {
                    const createdDate = new Date(task.createdAt);
                    return createdDate >= weekAgo;
                }).length;

                return {
                    todayCompleted,
                    weekCompleted,
                    weekTotal,
                    totalTasks: this.state.tasks.length,
                    totalCompleted: this.state.tasks.filter(t => t.completed).length
                };
            }

            calculateStreak() {
                const completedDates = this.state.tasks
                    .filter(task => task.completed && task.completedAt)
                    .map(task => {
                        const date = new Date(task.completedAt);
                        return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
                    })
                    .filter((date, index, array) => array.indexOf(date) === index) // Unique dates
                    .sort((a, b) => b - a); // Most recent first

                if (completedDates.length === 0) return 0;

                const today = new Date();
                const todayTime = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
                const yesterdayTime = todayTime - (24 * 60 * 60 * 1000);

                let streak = 0;
                let currentDate = todayTime;

                // Commencer par aujourd'hui ou hier
                if (completedDates.includes(todayTime)) {
                    streak = 1;
                    currentDate = todayTime;
                } else if (completedDates.includes(yesterdayTime)) {
                    streak = 1;
                    currentDate = yesterdayTime;
                } else {
                    return 0;
                }

                // Compter les jours consécutifs
                for (let i = 1; i < completedDates.length; i++) {
                    const expectedDate = currentDate - (24 * 60 * 60 * 1000);
                    if (completedDates.includes(expectedDate)) {
                        streak++;
                        currentDate = expectedDate;
                    } else {
                        break;
                    }
                }

                return streak;
            }

            renderMiniChart() {
                const chartContainer = document.getElementById('mini-chart');
                if (!chartContainer) return;

                const last7Days = [];
                const today = new Date();

                for (let i = 6; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dayStart = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                    const dayEnd = new Date(dayStart);
                    dayEnd.setDate(dayEnd.getDate() + 1);

                    const completed = this.state.tasks.filter(task => {
                        if (!task.completed || !task.completedAt) return false;
                        const completedDate = new Date(task.completedAt);
                        return completedDate >= dayStart && completedDate < dayEnd;
                    }).length;

                    last7Days.push(completed);
                }

                const maxValue = Math.max(...last7Days, 1);
                chartContainer.innerHTML = '';

                last7Days.forEach((value, index) => {
                    const bar = document.createElement('div');
                    bar.className = 'chart-bar';
                    bar.style.left = `${(index * 14.28)}%`;
                    bar.style.width = '12%';
                    bar.style.height = `${(value / maxValue) * 100}%`;
                    bar.title = `${value} tâche${value > 1 ? 's' : ''} terminée${value > 1 ? 's' : ''}`;
                    chartContainer.appendChild(bar);
                });
            }

            showDetailedStats() {
                const stats = this.calculateDetailedStats();
                const streak = this.calculateStreak();

                const statsHTML = `
                    <div class="modal-content detailed-stats-modal" style="margin: 20px auto; background: var(--bg-primary); padding: var(--spacing-xl); border-radius: var(--border-radius-lg); box-shadow: var(--shadow-lg);">
                        <h2 style="margin-bottom: var(--spacing-lg); text-align: center;">📊 Statistiques détaillées</h2>

                        <div class="stats-grid">
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.totalCompleted}</div>
                                <div class="stats-card-label">Tâches terminées</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.totalTasks}</div>
                                <div class="stats-card-label">Total des tâches</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${Math.round(stats.completionRate)}%</div>
                                <div class="stats-card-label">Taux de réussite</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${streak}</div>
                                <div class="stats-card-label">Série actuelle (jours)</div>
                            </div>
                        </div>

                        <div class="stats-grid">
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.thisWeekCompleted}</div>
                                <div class="stats-card-label">Cette semaine</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.thisMonthCompleted}</div>
                                <div class="stats-card-label">Ce mois</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.averagePerDay.toFixed(1)}</div>
                                <div class="stats-card-label">Moyenne/jour</div>
                            </div>
                            <div class="stats-card">
                                <div class="stats-card-value">${stats.highPriorityCompleted}</div>
                                <div class="stats-card-label">Priorité haute terminées</div>
                            </div>
                        </div>

                        <h3 style="margin: var(--spacing-xl) 0 var(--spacing-md);">📈 Productivité par catégorie</h3>
                        <div class="category-stats">
                            ${this.renderCategoryStats(stats.categoryStats)}
                        </div>

                        <h3 style="margin: var(--spacing-xl) 0 var(--spacing-md);">🏆 Réalisations</h3>
                        <div class="achievements">
                            ${this.renderAchievements(stats)}
                        </div>

                        <div style="margin-top: var(--spacing-xl); text-align: center;">
                            <button class="btn btn-primary" onclick="app.closeSettings()">
                                Fermer
                            </button>
                        </div>
                    </div>
                `;

                const overlay = document.getElementById('modal-overlay');
                overlay.innerHTML = statsHTML;
                overlay.classList.remove('hidden');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 1000;
                    display: flex;
                    align-items: flex-start;
                    justify-content: center;
                    overflow-y: auto;
                `;
            }

            calculateDetailedStats() {
                const now = new Date();
                const weekStart = new Date(now);
                weekStart.setDate(now.getDate() - now.getDay());
                weekStart.setHours(0, 0, 0, 0);

                const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);

                const totalTasks = this.state.tasks.length;
                const totalCompleted = this.state.tasks.filter(t => t.completed).length;
                const completionRate = totalTasks > 0 ? (totalCompleted / totalTasks) * 100 : 0;

                const thisWeekCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    return new Date(task.completedAt) >= weekStart;
                }).length;

                const thisMonthCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    return new Date(task.completedAt) >= monthStart;
                }).length;

                const highPriorityCompleted = this.state.tasks.filter(task =>
                    task.completed && (task.priority === 'high' || task.priority === 'critical')
                ).length;

                // Calculer la moyenne par jour (sur les 30 derniers jours)
                const thirtyDaysAgo = new Date(now);
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

                const last30DaysCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    return new Date(task.completedAt) >= thirtyDaysAgo;
                }).length;

                const averagePerDay = last30DaysCompleted / 30;

                // Statistiques par catégorie
                const categoryStats = {};
                this.state.categories.forEach(category => {
                    const categoryTasks = this.state.tasks.filter(t => t.category === category.id);
                    const categoryCompleted = categoryTasks.filter(t => t.completed).length;
                    categoryStats[category.id] = {
                        name: category.name,
                        color: category.color,
                        total: categoryTasks.length,
                        completed: categoryCompleted,
                        rate: categoryTasks.length > 0 ? (categoryCompleted / categoryTasks.length) * 100 : 0
                    };
                });

                return {
                    totalTasks,
                    totalCompleted,
                    completionRate,
                    thisWeekCompleted,
                    thisMonthCompleted,
                    averagePerDay,
                    highPriorityCompleted,
                    categoryStats
                };
            }

            renderCategoryStats(categoryStats) {
                let html = '';
                Object.values(categoryStats).forEach(cat => {
                    if (cat.total > 0) {
                        html += `
                            <div class="stat-item">
                                <span class="stat-label">
                                    <span style="display: inline-block; width: 12px; height: 12px; background: ${cat.color}; border-radius: 50%; margin-right: 8px;"></span>
                                    ${cat.name}
                                </span>
                                <span class="stat-value">${cat.completed}/${cat.total} (${Math.round(cat.rate)}%)</span>
                            </div>
                        `;
                    }
                });
                return html || '<p class="text-muted">Aucune donnée disponible</p>';
            }

            renderAchievements(stats) {
                const achievements = [];

                if (stats.totalCompleted >= 10) achievements.push('🏅 10 tâches terminées');
                if (stats.totalCompleted >= 50) achievements.push('🏆 50 tâches terminées');
                if (stats.totalCompleted >= 100) achievements.push('💎 100 tâches terminées');
                if (stats.completionRate >= 80) achievements.push('⭐ Taux de réussite élevé');
                if (stats.thisWeekCompleted >= 7) achievements.push('🔥 Semaine productive');
                if (this.calculateStreak() >= 7) achievements.push('📅 Série de 7 jours');
                if (stats.highPriorityCompleted >= 10) achievements.push('🎯 Maître des priorités');

                if (achievements.length === 0) {
                    return '<p class="text-muted">Continuez à terminer des tâches pour débloquer des réalisations !</p>';
                }

                return achievements.map(achievement =>
                    `<div class="achievement-item" style="padding: var(--spacing-sm); background: var(--secondary-color)20; border-radius: var(--border-radius); margin-bottom: var(--spacing-xs);">${achievement}</div>`
                ).join('');
            }

            // Système d'IA simulée et gamification

            renderAISuggestions() {
                const suggestionsContainer = document.getElementById('ai-suggestions');
                if (!suggestionsContainer) return;

                const suggestions = this.generateAISuggestions();

                if (suggestions.length === 0) {
                    suggestionsContainer.innerHTML = '<p class="text-muted text-xs">Aucune suggestion pour le moment</p>';
                    return;
                }

                let suggestionsHTML = '';
                suggestions.slice(0, 3).forEach(suggestion => {
                    suggestionsHTML += `
                        <div class="suggestion-item" onclick="app.applySuggestion('${suggestion.type}', '${suggestion.data}')">
                            <span class="suggestion-icon">${suggestion.icon}</span>
                            <span class="suggestion-text">${suggestion.text}</span>
                        </div>
                    `;
                });

                suggestionsContainer.innerHTML = suggestionsHTML;
            }

            generateAISuggestions() {
                const suggestions = [];
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

                // Suggestion basée sur les tâches en retard
                const overdueTasks = this.state.tasks.filter(task =>
                    task.dueDate && new Date(task.dueDate) < today && !task.completed
                );

                if (overdueTasks.length > 0) {
                    suggestions.push({
                        type: 'focus_overdue',
                        icon: '⚠️',
                        text: `Vous avez ${overdueTasks.length} tâche${overdueTasks.length > 1 ? 's' : ''} en retard. Concentrez-vous dessus !`,
                        data: 'overdue'
                    });
                }

                // Suggestion basée sur les priorités
                const highPriorityPending = this.state.tasks.filter(task =>
                    !task.completed && (task.priority === 'critical' || task.priority === 'high')
                );

                if (highPriorityPending.length > 0) {
                    suggestions.push({
                        type: 'focus_priority',
                        icon: '🔥',
                        text: `${highPriorityPending.length} tâche${highPriorityPending.length > 1 ? 's' : ''} prioritaire${highPriorityPending.length > 1 ? 's' : ''} en attente`,
                        data: 'high-priority'
                    });
                }

                // Suggestion basée sur les catégories
                const categoryStats = {};
                this.state.tasks.forEach(task => {
                    if (task.category && !task.completed) {
                        categoryStats[task.category] = (categoryStats[task.category] || 0) + 1;
                    }
                });

                const mostUsedCategory = Object.keys(categoryStats).reduce((a, b) =>
                    categoryStats[a] > categoryStats[b] ? a : b, null
                );

                if (mostUsedCategory) {
                    const category = this.state.categories.find(c => c.id === mostUsedCategory);
                    if (category) {
                        suggestions.push({
                            type: 'focus_category',
                            icon: '📂',
                            text: `Beaucoup de tâches en "${category.name}". Organisez une session dédiée !`,
                            data: mostUsedCategory
                        });
                    }
                }

                // Suggestion de pause si beaucoup de tâches terminées aujourd'hui
                const todayCompleted = this.state.tasks.filter(task => {
                    if (!task.completed || !task.completedAt) return false;
                    const completedDate = new Date(task.completedAt);
                    return completedDate >= today;
                }).length;

                if (todayCompleted >= 5) {
                    suggestions.push({
                        type: 'take_break',
                        icon: '☕',
                        text: `Excellent ! ${todayCompleted} tâches terminées aujourd'hui. Prenez une pause bien méritée !`,
                        data: 'break'
                    });
                }

                // Suggestion de Pomodoro
                const pendingTasks = this.state.tasks.filter(t => !t.completed).length;
                if (pendingTasks > 0 && (!this.state.pomodoro || !this.state.pomodoro.isRunning)) {
                    suggestions.push({
                        type: 'start_pomodoro',
                        icon: '🍅',
                        text: 'Démarrez un timer Pomodoro pour rester concentré !',
                        data: 'pomodoro'
                    });
                }

                return suggestions;
            }

            applySuggestion(type, data) {
                switch (type) {
                    case 'focus_overdue':
                        this.changeFilter('overdue');
                        this.showNotification('Filtrage sur les tâches en retard', 'info');
                        break;
                    case 'focus_priority':
                        this.changeFilter('high-priority');
                        this.showNotification('Filtrage sur les priorités hautes', 'info');
                        break;
                    case 'focus_category':
                        this.filterByCategory(data);
                        this.showNotification('Filtrage par catégorie appliqué', 'info');
                        break;
                    case 'take_break':
                        this.showNotification('Vous le méritez ! Prenez une pause 😊', 'success');
                        break;
                    case 'start_pomodoro':
                        this.togglePomodoroTimer();
                        break;
                }
            }

            renderDailyChallenge() {
                const challengeContainer = document.getElementById('daily-challenge');
                if (!challengeContainer) return;

                const challenge = this.getDailyChallenge();
                const progress = this.getChallengeProgress(challenge);

                const challengeHTML = `
                    <div class="challenge-card">
                        <div class="challenge-title">${challenge.icon} ${challenge.title}</div>
                        <div class="challenge-description">${challenge.description}</div>
                        <div class="challenge-progress">
                            <div class="challenge-progress-bar" style="width: ${progress.percentage}%"></div>
                        </div>
                        <div class="challenge-reward">
                            ${progress.current}/${progress.target} • Récompense: ${challenge.reward} points
                        </div>
                    </div>
                `;

                challengeContainer.innerHTML = challengeHTML;

                // Vérifier si le défi est terminé
                if (progress.percentage >= 100 && !challenge.completed) {
                    this.completeDailyChallenge(challenge);
                }
            }

            getDailyChallenge() {
                const today = new Date().toDateString();

                // Vérifier si on a déjà un défi pour aujourd'hui
                if (this.state.dailyChallenge && this.state.dailyChallenge.date === today) {
                    return this.state.dailyChallenge;
                }

                // Générer un nouveau défi
                const challenges = [
                    {
                        id: 'complete_3_tasks',
                        title: 'Productivité',
                        description: 'Terminez 3 tâches aujourd\'hui',
                        icon: '🎯',
                        target: 3,
                        type: 'complete_tasks',
                        reward: 100
                    },
                    {
                        id: 'complete_high_priority',
                        title: 'Priorités',
                        description: 'Terminez 2 tâches de haute priorité',
                        icon: '🔥',
                        target: 2,
                        type: 'complete_high_priority',
                        reward: 150
                    },
                    {
                        id: 'use_pomodoro',
                        title: 'Focus',
                        description: 'Utilisez le timer Pomodoro 2 fois',
                        icon: '🍅',
                        target: 2,
                        type: 'use_pomodoro',
                        reward: 80
                    },
                    {
                        id: 'organize_tasks',
                        title: 'Organisation',
                        description: 'Ajoutez 5 nouvelles tâches avec catégories',
                        icon: '📋',
                        target: 5,
                        type: 'add_categorized_tasks',
                        reward: 120
                    }
                ];

                const randomChallenge = challenges[Math.floor(Math.random() * challenges.length)];
                randomChallenge.date = today;
                randomChallenge.completed = false;

                this.state.dailyChallenge = randomChallenge;
                this.saveState();

                return randomChallenge;
            }

            getChallengeProgress(challenge) {
                const today = new Date();
                const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());

                let current = 0;

                switch (challenge.type) {
                    case 'complete_tasks':
                        current = this.state.tasks.filter(task => {
                            if (!task.completed || !task.completedAt) return false;
                            return new Date(task.completedAt) >= todayStart;
                        }).length;
                        break;
                    case 'complete_high_priority':
                        current = this.state.tasks.filter(task => {
                            if (!task.completed || !task.completedAt) return false;
                            if (task.priority !== 'high' && task.priority !== 'critical') return false;
                            return new Date(task.completedAt) >= todayStart;
                        }).length;
                        break;
                    case 'use_pomodoro':
                        current = this.state.pomodoroSessionsToday || 0;
                        break;
                    case 'add_categorized_tasks':
                        current = this.state.tasks.filter(task => {
                            if (!task.category) return false;
                            return new Date(task.createdAt) >= todayStart;
                        }).length;
                        break;
                }

                const percentage = Math.min((current / challenge.target) * 100, 100);

                return {
                    current: Math.min(current, challenge.target),
                    target: challenge.target,
                    percentage
                };
            }

            completeDailyChallenge(challenge) {
                challenge.completed = true;
                this.addPoints(challenge.reward);
                this.showNotification(`Défi terminé ! +${challenge.reward} points 🎉`, 'success');
                this.saveState();
            }

            // Documentation et aide
            showHelp() {
                const helpHTML = `
                    <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow-y: auto; margin: 20px auto; background: var(--bg-primary); padding: var(--spacing-xl); border-radius: var(--border-radius-lg); box-shadow: var(--shadow-lg);">
                        <h2 style="margin-bottom: var(--spacing-lg); text-align: center;">📚 Guide d'utilisation - TodoList Pro</h2>

                        <div class="help-section">
                            <h3>🚀 Démarrage rapide</h3>
                            <ul style="margin: var(--spacing-md) 0; padding-left: var(--spacing-lg);">
                                <li>Tapez <kbd>N</kbd> pour ajouter une nouvelle tâche rapidement</li>
                                <li>Utilisez <kbd>F</kbd> pour rechercher dans vos tâches</li>
                                <li>Cliquez sur les icônes de priorité pour organiser vos tâches</li>
                                <li>Glissez-déposez les tâches pour les réorganiser</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>⌨️ Raccourcis clavier</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-md); margin: var(--spacing-md) 0;">
                                <div>
                                    <strong>Navigation :</strong><br>
                                    <kbd>N</kbd> - Nouvelle tâche<br>
                                    <kbd>F</kbd> - Rechercher<br>
                                    <kbd>Escape</kbd> - Effacer recherche<br>
                                    <kbd>?</kbd> - Afficher l'aide
                                </div>
                                <div>
                                    <strong>Productivité :</strong><br>
                                    <kbd>T</kbd> - Timer Pomodoro<br>
                                    <kbd>Z</kbd> - Mode Focus<br>
                                    <kbd>D</kbd> - Changer de thème<br>
                                    <kbd>S</kbd> - Sauvegarder
                                </div>
                            </div>
                        </div>

                        <div style="margin-top: var(--spacing-xl); text-align: center; padding-top: var(--spacing-lg); border-top: 1px solid var(--bg-tertiary);">
                            <p style="color: var(--text-muted); font-size: 0.875rem; margin-bottom: var(--spacing-md);">
                                TodoList Pro - Application de productivité avancée<br>
                                Version 1.0 - Développée avec ❤️ pour votre productivité
                            </p>
                            <button class="btn btn-primary" onclick="app.closeSettings()">
                                Fermer l'aide
                            </button>
                        </div>
                    </div>
                `;

                const overlay = document.getElementById('modal-overlay');
                overlay.innerHTML = helpHTML;
                overlay.classList.remove('hidden');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 1000;
                    display: flex;
                    align-items: flex-start;
                    justify-content: center;
                    overflow-y: auto;
                `;
            }

            // Tests et validation
            runSelfTests() {
                console.log('🧪 Exécution des tests automatiques...');

                const tests = [
                    () => this.testTaskCreation(),
                    () => this.testTaskCompletion(),
                    () => this.testCategoryManagement(),
                    () => this.testSearchFunctionality(),
                    () => this.testDataPersistence(),
                    () => this.testAccessibility(),
                    () => this.testPerformance()
                ];

                let passed = 0;
                let failed = 0;

                tests.forEach((test, index) => {
                    try {
                        test();
                        console.log(`✅ Test ${index + 1} réussi`);
                        passed++;
                    } catch (error) {
                        console.error(`❌ Test ${index + 1} échoué:`, error);
                        failed++;
                    }
                });

                console.log(`📊 Résultats des tests: ${passed} réussis, ${failed} échoués`);
                return { passed, failed };
            }

            testTaskCreation() {
                const initialCount = this.state.tasks.length;
                const testTask = {
                    id: 'test-' + Date.now(),
                    title: 'Test Task',
                    completed: false,
                    createdAt: new Date().toISOString(),
                    priority: 'normal'
                };

                this.state.tasks.push(testTask);

                if (this.state.tasks.length !== initialCount + 1) {
                    throw new Error('Task creation failed');
                }

                // Nettoyer
                this.state.tasks = this.state.tasks.filter(t => t.id !== testTask.id);
            }

            testTaskCompletion() {
                const testTask = {
                    id: 'test-completion-' + Date.now(),
                    title: 'Test Completion',
                    completed: false,
                    createdAt: new Date().toISOString(),
                    priority: 'normal'
                };

                this.state.tasks.push(testTask);

                // Simuler la completion
                testTask.completed = true;
                testTask.completedAt = new Date().toISOString();

                if (!testTask.completed || !testTask.completedAt) {
                    throw new Error('Task completion failed');
                }

                // Nettoyer
                this.state.tasks = this.state.tasks.filter(t => t.id !== testTask.id);
            }

            testCategoryManagement() {
                const initialCount = this.state.categories.length;
                const testCategory = {
                    id: 'test-cat-' + Date.now(),
                    name: 'Test Category',
                    color: '#ff0000',
                    createdAt: new Date().toISOString()
                };

                this.state.categories.push(testCategory);

                if (this.state.categories.length !== initialCount + 1) {
                    throw new Error('Category creation failed');
                }

                // Nettoyer
                this.state.categories = this.state.categories.filter(c => c.id !== testCategory.id);
            }

            testSearchFunctionality() {
                const testTasks = [
                    { id: '1', title: 'Test Search Task', completed: false },
                    { id: '2', title: 'Another Task', completed: false }
                ];

                const originalTasks = this.state.tasks;
                this.state.tasks = testTasks;

                const results = this.searchTasks('Search');

                if (results.length !== 1 || results[0].title !== 'Test Search Task') {
                    throw new Error('Search functionality failed');
                }

                // Restaurer
                this.state.tasks = originalTasks;
            }

            testDataPersistence() {
                const testData = { test: 'persistence' };
                localStorage.setItem('todoapp-test', JSON.stringify(testData));

                const retrieved = JSON.parse(localStorage.getItem('todoapp-test'));

                if (!retrieved || retrieved.test !== 'persistence') {
                    throw new Error('Data persistence failed');
                }

                // Nettoyer
                localStorage.removeItem('todoapp-test');
            }

            testAccessibility() {
                const liveRegion = document.getElementById('aria-live-region');
                if (!liveRegion) {
                    throw new Error('Accessibility live region not found');
                }

                if (!liveRegion.getAttribute('aria-live')) {
                    throw new Error('Accessibility attributes missing');
                }
            }

            testPerformance() {
                const start = performance.now();

                // Simuler une opération coûteuse
                for (let i = 0; i < 1000; i++) {
                    this.calculateStats();
                }

                const end = performance.now();
                const duration = end - start;

                if (duration > 1000) { // Plus d'une seconde
                    throw new Error(`Performance test failed: ${duration}ms`);
                }
            }
        }

        // Initialisation de l'application
        const app = new TodoApp();

        // Fallback pour s'assurer que l'app est visible
        setTimeout(() => {
            const appElement = document.getElementById('app');
            const loadingScreen = document.getElementById('loading-screen');

            if (appElement && appElement.style.opacity !== '1') {
                console.log('🔧 Fallback: Affichage forcé de l\'application');
                appElement.style.opacity = '1';
                appElement.style.transition = 'opacity 0.3s ease-out';
            }

            if (loadingScreen) {
                loadingScreen.remove();
            }
        }, 1200); // Fallback après 1.2 secondes

        // Exécuter les tests en mode développement
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('🚀 TodoList Pro - Mode développement détecté');
            setTimeout(() => {
                const testResults = app.runSelfTests();
                if (testResults.failed === 0) {
                    console.log('✅ Tous les tests sont passés avec succès !');
                } else {
                    console.warn(`⚠️ ${testResults.failed} test(s) ont échoué`);
                }
            }, 2500);
        }
    </script>
</body>

</html>